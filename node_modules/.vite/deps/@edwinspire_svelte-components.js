import {
  utils,
  writeFileSync,
  xlsx_exports
} from "./chunk-TDCSAC2Q.js";
import "./chunk-X7HCJ7ZS.js";
import {
  require_fetch
} from "./chunk-WTP6JZ2J.js";
import {
  DateTime
} from "./chunk-3DMGICC5.js";
import {
  axisBottom,
  axisLeft,
  brushX,
  catmullRom_default,
  extent,
  line_default,
  linear2 as linear,
  max,
  select_default,
  src_exports,
  time,
  timeFormat
} from "./chunk-CAK6Z4L5.js";
import {
  require_events
} from "./chunk-PY7KARX4.js";
import "./chunk-YHNR2Q4Z.js";
import {
  writable
} from "./chunk-PUW3LW7T.js";
import {
  slide
} from "./chunk-6CGBUDNE.js";
import "./chunk-VFRMSNTO.js";
import {
  SvelteComponentDev,
  add_flush_callback,
  add_iframe_resize_listener,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  compute_slots,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_svelte_dataset,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  prop_dev,
  run_all,
  safe_not_equal,
  select_option,
  select_value,
  set_data_dev,
  set_input_value,
  set_style,
  space,
  svg_element,
  text,
  to_number,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots
} from "./chunk-ABQMC7CZ.js";
import "./chunk-3AXIZ4GY.js";
import {
  __export,
  __toESM
} from "./chunk-UV5CTPV7.js";

// node_modules/@edwinspire/svelte-components/dist/index.js
import "/home/edwinspire/Documentos/Desarrollo/libOpenFusionAPIGUI/node_modules/bulma/css/bulma.min.css";
import "/home/edwinspire/Documentos/Desarrollo/libOpenFusionAPIGUI/node_modules/@fortawesome/fontawesome-free/css/all.min.css";

// node_modules/@edwinspire/svelte-components/dist/Table/Table.svelte
var import_universal_fetch = __toESM(require_fetch());

// node_modules/@edwinspire/svelte-components/dist/Table/Column/DefaultTypes.js
var DefaultTypes_exports = {};
__export(DefaultTypes_exports, {
  Auto: () => Auto_default,
  Boolean: () => Boolean_default,
  BooleanIcon: () => BooleanIcon_default,
  DateTime: () => DateTime_default,
  Json: () => JSON_default,
  TextLimit: () => TextLimit_default
});

// node_modules/@edwinspire/svelte-components/dist/Table/Column/Boolean.svelte
var file = "node_modules/@edwinspire/svelte-components/dist/Table/Column/Boolean.svelte";
function create_else_block(ctx) {
  let td;
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      td = element("td");
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      input = claim_element(td_nodes, "INPUT", { type: true, onclick: true });
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      input.checked = /*value*/
      ctx[0];
      attr_dev(input, "onclick", "return false;");
      add_location(input, file, 51, 4, 1162);
      attr_dev(td, "class", "has-text-centered");
      add_location(td, file, 50, 2, 1118);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, input);
      if (!mounted) {
        dispose = listen_dev(
          td,
          "click",
          /*click_handler_1*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*value*/
      1) {
        prop_dev(
          input,
          "checked",
          /*value*/
          ctx2[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(50:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let td;
  let div;
  let span;
  let i;
  let i_class_value;
  let span_class_value;
  let td_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      td = element("td");
      div = element("div");
      span = element("span");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      div = claim_element(td_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      i = claim_element(span_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", i_class_value = /*option*/
      ctx[1][
        /*value*/
        ctx[0]
      ].icon);
      add_location(i, file, 45, 8, 1042);
      attr_dev(span, "class", span_class_value = /*option*/
      ctx[1][
        /*value*/
        ctx[0]
      ].class);
      add_location(span, file, 44, 6, 999);
      attr_dev(div, "class", "icon-text");
      add_location(div, file, 43, 4, 969);
      attr_dev(td, "class", td_class_value = /*option*/
      ctx[1][
        /*value*/
        ctx[0]
      ].td_class);
      add_location(td, file, 42, 2, 920);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, div);
      append_hydration_dev(div, span);
      append_hydration_dev(span, i);
      if (!mounted) {
        dispose = listen_dev(
          td,
          "click",
          /*click_handler*/
          ctx[4],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*option, value*/
      3 && i_class_value !== (i_class_value = /*option*/
      ctx2[1][
        /*value*/
        ctx2[0]
      ].icon)) {
        attr_dev(i, "class", i_class_value);
      }
      if (dirty & /*option, value*/
      3 && span_class_value !== (span_class_value = /*option*/
      ctx2[1][
        /*value*/
        ctx2[0]
      ].class)) {
        attr_dev(span, "class", span_class_value);
      }
      if (dirty & /*option, value*/
      3 && td_class_value !== (td_class_value = /*option*/
      ctx2[1][
        /*value*/
        ctx2[0]
      ].td_class)) {
        attr_dev(td, "class", td_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(42:0) {#if option}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*option*/
      ctx2[1]
    )
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Boolean", slots, []);
  "use strict";
  let { value } = $$props;
  const row = {};
  let { props = {} } = $$props;
  let option = "default";
  let config = {
    icon: {
      true: {
        td_class: "has-text-centered",
        class: "icon has-text-success",
        icon: "fas fa-check"
      },
      false: {
        td_class: "has-text-centered",
        class: "icon has-text-danger",
        icon: "fas fa-times"
      }
    },
    "color-icon": {
      true: {
        td_class: "has-background-success has-text-white has-text-centered",
        class: "icon",
        icon: "fas fa-check"
      },
      false: {
        td_class: "has-background-danger has-text-white has-text-centered",
        class: "icon",
        icon: "fas fa-times"
      }
    }
  };
  if (props && props.option) {
    option = config[props.option];
  } else {
    option = null;
  }
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<Boolean> was created without expected prop 'value'");
    }
  });
  const writable_props = ["value", "props"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Boolean> was created with unknown prop '${key}'`);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("props" in $$props2)
      $$invalidate(3, props = $$props2.props);
  };
  $$self.$capture_state = () => ({ value, row, props, option, config });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("props" in $$props2)
      $$invalidate(3, props = $$props2.props);
    if ("option" in $$props2)
      $$invalidate(1, option = $$props2.option);
    if ("config" in $$props2)
      config = $$props2.config;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, option, row, props, click_handler, click_handler_1];
}
var Boolean2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { value: 0, row: 2, props: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Boolean",
      options,
      id: create_fragment.name
    });
  }
  get value() {
    throw new Error("<Boolean>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Boolean>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get row() {
    return this.$$.ctx[2];
  }
  set row(value) {
    throw new Error("<Boolean>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<Boolean>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<Boolean>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Boolean_default = Boolean2;

// node_modules/@edwinspire/svelte-components/dist/Table/Column/TextLimit.svelte
var file2 = "node_modules/@edwinspire/svelte-components/dist/Table/Column/TextLimit.svelte";
function add_css(target) {
  append_styles(target, "svelte-guhau6", ".btn_show.svelte-guhau6{color:rgb(0, 34, 145);cursor:pointer}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dExpbWl0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFzQ0UsdUJBQVUsQ0FDUixLQUFLLENBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDdEIsTUFBTSxDQUFFLE9BQ1YiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVGV4dExpbWl0LnN2ZWx0ZSJdfQ== */");
}
function create_else_block_1(ctx) {
  let div;
  let t_value = JSON.stringify(
    /*value*/
    ctx[0]
  ) + "";
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file2, 33, 4, 694);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*value*/
      1 && t_value !== (t_value = JSON.stringify(
        /*value*/
        ctx2[0]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(33:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*value*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*value*/
        ctx[0]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file2, 29, 4, 649);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*value*/
      1)
        set_data_dev(
          t,
          /*value*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(29:38) ",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*show*/
      ctx2[2]
    )
      return create_if_block_1;
    return create_else_block2;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: '(17:2) {#if value && typeof value === \\"string\\" && value.length > LimitMax}',
    ctx
  });
  return block;
}
function create_else_block2(ctx) {
  let div;
  let t0_value = (
    /*value*/
    ctx[0].substring(
      0,
      /*LimitMax*/
      ctx[3]
    ) + ""
  );
  let t0;
  let t1;
  let span;
  let textContent = "ver más";
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = text("...\n        ");
      span = element("span");
      span.textContent = textContent;
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, t0_value);
      t1 = claim_text(div_nodes, "...\n        ");
      span = claim_element(div_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-tbjw8a")
        span.textContent = textContent;
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "btn_show svelte-guhau6");
      add_location(span, file2, 25, 8, 523);
      add_location(div, file2, 23, 6, 467);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, span);
      if (!mounted) {
        dispose = listen_dev(
          span,
          "click",
          /*ClickShow*/
          ctx[4],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*value, LimitMax*/
      9 && t0_value !== (t0_value = /*value*/
      ctx2[0].substring(
        0,
        /*LimitMax*/
        ctx2[3]
      ) + ""))
        set_data_dev(t0, t0_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(23:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let t0;
  let t1;
  let span;
  let textContent = "ver menos";
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(
        /*value*/
        ctx[0]
      );
      t1 = space();
      span = element("span");
      span.textContent = textContent;
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t0 = claim_text(
        div_nodes,
        /*value*/
        ctx[0]
      );
      t1 = claim_space(div_nodes);
      span = claim_element(div_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-a2llsj")
        span.textContent = textContent;
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "btn_show svelte-guhau6");
      add_location(span, file2, 20, 8, 374);
      add_location(div, file2, 18, 6, 344);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, span);
      if (!mounted) {
        dispose = listen_dev(
          span,
          "click",
          /*ClickShow*/
          ctx[4],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*value*/
      1)
        set_data_dev(
          t0,
          /*value*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(18:4) {#if show}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let td;
  let td_class_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*value*/
      ctx2[0] && typeof /*value*/
      ctx2[0] === "string" && /*value*/
      ctx2[0].length > /*LimitMax*/
      ctx2[3]
    )
      return create_if_block2;
    if (typeof /*value*/
    ctx2[0] === "string")
      return create_if_block_2;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      td = element("td");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      if_block.l(td_nodes);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "class", td_class_value = null_to_empty(
        /*props*/
        ctx[1].class
      ) + " svelte-guhau6");
      add_location(td, file2, 15, 0, 219);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      if_block.m(td, null);
      if (!mounted) {
        dispose = listen_dev(
          td,
          "click",
          /*click_handler*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(td, null);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextLimit", slots, []);
  let { value } = $$props;
  let show = false;
  let LimitMax = 30;
  const props = {};
  if (props && props.limit) {
    LimitMax = props.limit;
  }
  function ClickShow() {
    $$invalidate(2, show = !show);
  }
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<TextLimit> was created without expected prop 'value'");
    }
  });
  const writable_props = ["value"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TextLimit> was created with unknown prop '${key}'`);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$capture_state = () => ({ value, show, LimitMax, props, ClickShow });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("show" in $$props2)
      $$invalidate(2, show = $$props2.show);
    if ("LimitMax" in $$props2)
      $$invalidate(3, LimitMax = $$props2.LimitMax);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, props, show, LimitMax, ClickShow, click_handler];
}
var TextLimit = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { value: 0, props: 1 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextLimit",
      options,
      id: create_fragment2.name
    });
  }
  get value() {
    throw new Error("<TextLimit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TextLimit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    return this.$$.ctx[1];
  }
  set props(value) {
    throw new Error("<TextLimit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextLimit_default = TextLimit;

// node_modules/@edwinspire/svelte-components/dist/Table/Column/DateTime.svelte
var file3 = "node_modules/@edwinspire/svelte-components/dist/Table/Column/DateTime.svelte";
function create_fragment3(ctx) {
  let td;
  let t_value = DateTime.fromISO(
    /*value*/
    ctx[0]
  ).toFormat(
    /*format*/
    ctx[2]
  ) + "";
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      td = element("td");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", {});
      var td_nodes = children(td);
      t = claim_text(td_nodes, t_value);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(
        td,
        "has-text-danger",
        /*DC001*/
        ctx[1]
      );
      add_location(td, file3, 35, 0, 759);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, t);
      if (!mounted) {
        dispose = listen_dev(
          td,
          "click",
          /*click_handler*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*value, format*/
      5 && t_value !== (t_value = DateTime.fromISO(
        /*value*/
        ctx2[0]
      ).toFormat(
        /*format*/
        ctx2[2]
      ) + ""))
        set_data_dev(t, t_value);
      if (dirty & /*DC001*/
      2) {
        toggle_class(
          td,
          "has-text-danger",
          /*DC001*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DateTime", slots, []);
  let { value } = $$props;
  let { props } = $$props;
  const row = {};
  let DC001 = false;
  let format = "yyyy-MM-dd HH:mm:ss";
  let HighlightIsntToday = false;
  if (props) {
    if (props.format) {
      format = props.format;
    }
    if (props.highlight_isnt_today) {
      HighlightIsntToday = true;
    }
  }
  function fn_DC01() {
    $$invalidate(1, DC001 = HighlightIsntToday && DateTime.fromISO(value).toFormat("yyyy-MM-dd") !== DateTime.local().toFormat("yyyy-MM-dd"));
  }
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<DateTime> was created without expected prop 'value'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<DateTime> was created without expected prop 'props'");
    }
  });
  const writable_props = ["value", "props"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DateTime> was created with unknown prop '${key}'`);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("props" in $$props2)
      $$invalidate(3, props = $$props2.props);
  };
  $$self.$capture_state = () => ({
    value,
    props,
    row,
    DC001,
    DateTime,
    format,
    HighlightIsntToday,
    fn_DC01
  });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("props" in $$props2)
      $$invalidate(3, props = $$props2.props);
    if ("DC001" in $$props2)
      $$invalidate(1, DC001 = $$props2.DC001);
    if ("format" in $$props2)
      $$invalidate(2, format = $$props2.format);
    if ("HighlightIsntToday" in $$props2)
      HighlightIsntToday = $$props2.HighlightIsntToday;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    1) {
      $:
        value, fn_DC01();
    }
  };
  return [value, DC001, format, props, row, click_handler];
}
var DateTime_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { value: 0, props: 3, row: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DateTime_1",
      options,
      id: create_fragment3.name
    });
  }
  get value() {
    throw new Error("<DateTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<DateTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<DateTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<DateTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get row() {
    return this.$$.ctx[4];
  }
  set row(value) {
    throw new Error("<DateTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DateTime_default = DateTime_1;

// node_modules/@edwinspire/svelte-components/dist/Table/Column/CellJSON.svelte
var { Object: Object_1 } = globals;
var file4 = "node_modules/@edwinspire/svelte-components/dist/Table/Column/CellJSON.svelte";
function add_css2(target) {
  append_styles(target, "svelte-3fi4q1", ".left_space.svelte-3fi4q1{padding-left:1em\n  }\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2VsbEpTT04uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW9DRSx5QkFBVyxDQUNQLFlBQVksQ0FBRTtBQUNwQixFQUFFIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNlbGxKU09OLnN2ZWx0ZSJdfQ== */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i][0];
  child_ctx[3] = list[i][1];
  return child_ctx;
}
function create_else_block_12(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*internal_value*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*internal_value*/
        ctx[0]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file4, 32, 2, 871);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*internal_value*/
      1)
        set_data_dev(
          t,
          /*internal_value*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_12.name,
    type: "else",
    source: "(32:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(Object.entries(
    /*internal_value*/
    ctx[0]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*Object, internal_value, Array*/
      1) {
        each_value = ensure_array_like_dev(Object.entries(
          /*internal_value*/
          ctx2[0]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: '(21:0) {#if internal_value && (typeof internal_value === \\"object\\" || Array.isArray(internal_value))}',
    ctx
  });
  return block;
}
function create_else_block3(ctx) {
  let div;
  let b;
  let t0_value = (
    /*k1*/
    ctx[2] + ""
  );
  let t0;
  let t1;
  let t2;
  let t3_value = (
    /*v1*/
    ctx[3] + ""
  );
  let t3;
  const block = {
    c: function create() {
      div = element("div");
      b = element("b");
      t0 = text(t0_value);
      t1 = text(":");
      t2 = space();
      t3 = text(t3_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      b = claim_element(div_nodes, "B", {});
      var b_nodes = children(b);
      t0 = claim_text(b_nodes, t0_value);
      t1 = claim_text(b_nodes, ":");
      b_nodes.forEach(detach_dev);
      t2 = claim_space(div_nodes);
      t3 = claim_text(div_nodes, t3_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(b, file4, 28, 11, 817);
      add_location(div, file4, 28, 6, 812);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, b);
      append_hydration_dev(b, t0);
      append_hydration_dev(b, t1);
      append_hydration_dev(div, t2);
      append_hydration_dev(div, t3);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*internal_value*/
      1 && t0_value !== (t0_value = /*k1*/
      ctx2[2] + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*internal_value*/
      1 && t3_value !== (t3_value = /*v1*/
      ctx2[3] + ""))
        set_data_dev(t3, t3_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(28:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let details;
  let summary;
  let b;
  let t0_value = (
    /*k1*/
    ctx[2] + ""
  );
  let t0;
  let t1;
  let tcelljson;
  let t2;
  let current;
  tcelljson = new JSON_default({
    props: { value: (
      /*v1*/
      ctx[3]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      details = element("details");
      summary = element("summary");
      b = element("b");
      t0 = text(t0_value);
      t1 = space();
      create_component(tcelljson.$$.fragment);
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      details = claim_element(nodes, "DETAILS", { class: true });
      var details_nodes = children(details);
      summary = claim_element(details_nodes, "SUMMARY", {});
      var summary_nodes = children(summary);
      b = claim_element(summary_nodes, "B", {});
      var b_nodes = children(b);
      t0 = claim_text(b_nodes, t0_value);
      b_nodes.forEach(detach_dev);
      summary_nodes.forEach(detach_dev);
      t1 = claim_space(details_nodes);
      claim_component(tcelljson.$$.fragment, details_nodes);
      t2 = claim_space(details_nodes);
      details_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(b, file4, 24, 17, 722);
      add_location(summary, file4, 24, 8, 713);
      attr_dev(details, "class", "left_space svelte-3fi4q1");
      add_location(details, file4, 23, 6, 676);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, details, anchor);
      append_hydration_dev(details, summary);
      append_hydration_dev(summary, b);
      append_hydration_dev(b, t0);
      append_hydration_dev(details, t1);
      mount_component(tcelljson, details, null);
      append_hydration_dev(details, t2);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*internal_value*/
      1) && t0_value !== (t0_value = /*k1*/
      ctx2[2] + ""))
        set_data_dev(t0, t0_value);
      const tcelljson_changes = {};
      if (dirty & /*internal_value*/
      1)
        tcelljson_changes.value = /*v1*/
        ctx2[3];
      tcelljson.$set(tcelljson_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tcelljson.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tcelljson.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(details);
      }
      destroy_component(tcelljson);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: '(23:4) {#if v1 != null && (typeof v1 === \\"object\\" || Array.isArray(v1))}',
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_12, create_else_block3];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty & /*internal_value*/
    1)
      show_if = null;
    if (show_if == null)
      show_if = !!/*v1*/
      (ctx2[3] != null && (typeof /*v1*/
      ctx2[3] === "object" || Array.isArray(
        /*v1*/
        ctx2[3]
      )));
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(22:2) {#each Object.entries(internal_value) as [k1, v1]}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_else_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*internal_value*/
    1)
      show_if = null;
    if (show_if == null)
      show_if = !!/*internal_value*/
      (ctx2[0] && (typeof /*internal_value*/
      ctx2[0] === "object" || Array.isArray(
        /*internal_value*/
        ctx2[0]
      )));
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CellJSON", slots, []);
  let { value } = $$props;
  let internal_value;
  if (value != null && value && (typeof value === "object" || Array.isArray(value))) {
    internal_value = value;
  } else {
    try {
      internal_value = JSON.parse(value);
    } catch (error) {
      internal_value = value;
    }
  }
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<CellJSON> was created without expected prop 'value'");
    }
  });
  const writable_props = ["value"];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CellJSON> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
  };
  $$self.$capture_state = () => ({ value, TCellJSON: JSON_default, internal_value });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("internal_value" in $$props2)
      $$invalidate(0, internal_value = $$props2.internal_value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [internal_value, value];
}
var CellJSON = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { value: 1 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CellJSON",
      options,
      id: create_fragment4.name
    });
  }
  get value() {
    throw new Error("<CellJSON>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<CellJSON>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CellJSON_default = CellJSON;

// node_modules/@edwinspire/svelte-components/dist/Table/Column/JSON.svelte
var file5 = "node_modules/@edwinspire/svelte-components/dist/Table/Column/JSON.svelte";
function create_fragment5(ctx) {
  let td;
  let tcelljson;
  let td_class_value;
  let current;
  let mounted;
  let dispose;
  tcelljson = new CellJSON_default({
    props: { value: (
      /*value*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      td = element("td");
      create_component(tcelljson.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      claim_component(tcelljson.$$.fragment, td_nodes);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "class", td_class_value = /*props*/
      ctx[1].class);
      add_location(td, file5, 7, 0, 137);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      mount_component(tcelljson, td, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          td,
          "click",
          /*click_handler*/
          ctx[3],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const tcelljson_changes = {};
      if (dirty & /*value*/
      1)
        tcelljson_changes.value = /*value*/
        ctx2[0];
      tcelljson.$set(tcelljson_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tcelljson.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tcelljson.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      destroy_component(tcelljson);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("JSON", slots, []);
  let { value } = $$props;
  const row = {};
  const props = {};
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<JSON> was created without expected prop 'value'");
    }
  });
  const writable_props = ["value"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<JSON> was created with unknown prop '${key}'`);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$capture_state = () => ({ TCellJSON: CellJSON_default, value, row, props });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, props, row, click_handler];
}
var JSON2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { value: 0, row: 2, props: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSON",
      options,
      id: create_fragment5.name
    });
  }
  get value() {
    throw new Error("<JSON>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<JSON>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get row() {
    return this.$$.ctx[2];
  }
  set row(value) {
    throw new Error("<JSON>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    return this.$$.ctx[1];
  }
  set props(value) {
    throw new Error("<JSON>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var JSON_default = JSON2;

// node_modules/@edwinspire/svelte-components/dist/Table/Column/Auto.svelte
var file6 = "node_modules/@edwinspire/svelte-components/dist/Table/Column/Auto.svelte";
function add_css3(target) {
  append_styles(target, "svelte-bpvtaf", ".text_end.svelte-bpvtaf{text-align:end}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXV0by5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBOENFLHVCQUFVLENBQ1IsVUFBVSxDQUFFLEdBQ2QiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQXV0by5zdmVsdGUiXX0= */");
}
function create_else_block_13(ctx) {
  let span;
  let t_value = JSON.stringify(
    /*value*/
    ctx[0]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file6, 41, 4, 1330);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*value*/
      1 && t_value !== (t_value = JSON.stringify(
        /*value*/
        ctx2[0]
      ) + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_13.name,
    type: "else",
    source: "(41:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_22, create_if_block_3, create_else_block4];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty & /*value*/
    1)
      show_if = null;
    if (show_if == null)
      show_if = !!(typeof /*value*/
      ctx2[0] === "string" && stringIsValidJSON(
        /*value*/
        ctx2[0]
      ) && (typeof JSON.parse(
        /*value*/
        ctx2[0]
      ) === "object" || Array.isArray(typeof JSON.parse(
        /*value*/
        ctx2[0]
      ))));
    if (show_if)
      return 0;
    if (typeof /*value*/
    ctx2[0] === "number")
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(29:158) ",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let details;
  let summary;
  let t0;
  let b;
  let t1_value = typeof /*value*/
  ctx[0];
  let t1;
  let t2;
  let t3;
  let tcelljson;
  let current;
  tcelljson = new CellJSON_default({
    props: { value: (
      /*value*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      details = element("details");
      summary = element("summary");
      t0 = text("[");
      b = element("b");
      t1 = text(t1_value);
      t2 = text("]");
      t3 = space();
      create_component(tcelljson.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      details = claim_element(nodes, "DETAILS", {});
      var details_nodes = children(details);
      summary = claim_element(details_nodes, "SUMMARY", {});
      var summary_nodes = children(summary);
      t0 = claim_text(summary_nodes, "[");
      b = claim_element(summary_nodes, "B", {});
      var b_nodes = children(b);
      t1 = claim_text(b_nodes, t1_value);
      b_nodes.forEach(detach_dev);
      t2 = claim_text(summary_nodes, "]");
      summary_nodes.forEach(detach_dev);
      t3 = claim_space(details_nodes);
      claim_component(tcelljson.$$.fragment, details_nodes);
      details_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(b, file6, 25, 16, 594);
      add_location(summary, file6, 25, 6, 584);
      add_location(details, file6, 24, 4, 568);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, details, anchor);
      append_hydration_dev(details, summary);
      append_hydration_dev(summary, t0);
      append_hydration_dev(summary, b);
      append_hydration_dev(b, t1);
      append_hydration_dev(summary, t2);
      append_hydration_dev(details, t3);
      mount_component(tcelljson, details, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*value*/
      1) && t1_value !== (t1_value = typeof /*value*/
      ctx2[0]))
        set_data_dev(t1, t1_value);
      const tcelljson_changes = {};
      if (dirty & /*value*/
      1)
        tcelljson_changes.value = /*value*/
        ctx2[0];
      tcelljson.$set(tcelljson_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tcelljson.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tcelljson.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(details);
      }
      destroy_component(tcelljson);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: '(24:2) {#if value && (typeof value === \\"object\\" || Array.isArray(value))}',
    ctx
  });
  return block;
}
function create_else_block4(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*value*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*value*/
        ctx[0]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file6, 38, 6, 1287);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*value*/
      1)
        set_data_dev(
          t,
          /*value*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(37:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*value*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*value*/
        ctx[0]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "text_end svelte-bpvtaf");
      add_location(div, file6, 35, 6, 1170);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*value*/
      1)
        set_data_dev(
          t,
          /*value*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(35:40) ",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let details;
  let summary;
  let t0;
  let b;
  let t1_value = typeof JSON.parse(
    /*value*/
    ctx[0]
  );
  let t1;
  let t2;
  let t3;
  let tcelljson;
  let current;
  tcelljson = new CellJSON_default({
    props: { value: JSON.parse(
      /*value*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      details = element("details");
      summary = element("summary");
      t0 = text("[");
      b = element("b");
      t1 = text(t1_value);
      t2 = text("]");
      t3 = space();
      create_component(tcelljson.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      details = claim_element(nodes, "DETAILS", {});
      var details_nodes = children(details);
      summary = claim_element(details_nodes, "SUMMARY", {});
      var summary_nodes = children(summary);
      t0 = claim_text(summary_nodes, "[");
      b = claim_element(summary_nodes, "B", {});
      var b_nodes = children(b);
      t1 = claim_text(b_nodes, t1_value);
      b_nodes.forEach(detach_dev);
      t2 = claim_text(summary_nodes, "]");
      summary_nodes.forEach(detach_dev);
      t3 = claim_space(details_nodes);
      claim_component(tcelljson.$$.fragment, details_nodes);
      details_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(b, file6, 31, 18, 1013);
      add_location(summary, file6, 31, 8, 1003);
      add_location(details, file6, 30, 6, 985);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, details, anchor);
      append_hydration_dev(details, summary);
      append_hydration_dev(summary, t0);
      append_hydration_dev(summary, b);
      append_hydration_dev(b, t1);
      append_hydration_dev(summary, t2);
      append_hydration_dev(details, t3);
      mount_component(tcelljson, details, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*value*/
      1) && t1_value !== (t1_value = typeof JSON.parse(
        /*value*/
        ctx2[0]
      )))
        set_data_dev(t1, t1_value);
      const tcelljson_changes = {};
      if (dirty & /*value*/
      1)
        tcelljson_changes.value = JSON.parse(
          /*value*/
          ctx2[0]
        );
      tcelljson.$set(tcelljson_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tcelljson.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tcelljson.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(details);
      }
      destroy_component(tcelljson);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: '(30:4) {#if typeof value === \\"string\\" && stringIsValidJSON(value) && (typeof JSON.parse(value) === \\"object\\" || Array.isArray(typeof JSON.parse(value)))}',
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let td;
  let show_if;
  let current_block_type_index;
  let if_block;
  let td_class_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block4, create_if_block_13, create_else_block_13];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*value*/
    1)
      show_if = null;
    if (show_if == null)
      show_if = !!/*value*/
      (ctx2[0] && (typeof /*value*/
      ctx2[0] === "object" || Array.isArray(
        /*value*/
        ctx2[0]
      )));
    if (show_if)
      return 0;
    if (typeof /*value*/
    ctx2[0] === "string" || typeof /*value*/
    ctx2[0] === "number" || typeof /*value*/
    ctx2[0] === "bigint" || typeof /*value*/
    ctx2[0] === "boolean" || typeof /*value*/
    ctx2[0] === "undefined")
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      td = element("td");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      if_block.l(td_nodes);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "class", td_class_value = null_to_empty(
        /*props*/
        ctx[1].class
      ) + " svelte-bpvtaf");
      add_location(td, file6, 22, 0, 461);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      if_blocks[current_block_type_index].m(td, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          td,
          "click",
          /*click_handler*/
          ctx[2],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(td, null);
      }
      if (!current || dirty & /*props*/
      2 && td_class_value !== (td_class_value = null_to_empty(
        /*props*/
        ctx2[1].class
      ) + " svelte-bpvtaf")) {
        attr_dev(td, "class", td_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function stringIsValidJSON(input) {
  if (typeof input === "string") {
    try {
      let x = JSON.parse(input);
      return true;
    } catch (error) {
      return false;
    }
  } else {
    return false;
  }
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Auto", slots, []);
  let { value } = $$props;
  let { props = {} } = $$props;
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<Auto> was created without expected prop 'value'");
    }
  });
  const writable_props = ["value", "props"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Auto> was created with unknown prop '${key}'`);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
  };
  $$self.$capture_state = () => ({
    TCellJSON: CellJSON_default,
    value,
    props,
    stringIsValidJSON
  });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, props, click_handler];
}
var Auto = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { value: 0, props: 1 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Auto",
      options,
      id: create_fragment6.name
    });
  }
  get value() {
    throw new Error("<Auto>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Auto>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<Auto>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<Auto>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Auto_default = Auto;

// node_modules/@edwinspire/svelte-components/dist/Table/Column/BooleanIcon.svelte
var file7 = "node_modules/@edwinspire/svelte-components/dist/Table/Column/BooleanIcon.svelte";
function create_else_block_14(ctx) {
  let i;
  let i_class_value;
  const block = {
    c: function create() {
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", i_class_value = /*props*/
      ctx[1] && /*props*/
      ctx[1]["onfalse"] && /*props*/
      ctx[1]["onfalse"].iconClass ? (
        /*props*/
        ctx[1]["onfalse"].iconClass
      ) : (
        /*defaultProps*/
        ctx[2]["onfalse"].iconClass
      ));
      add_location(i, file7, 46, 4, 1176);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*props*/
      2 && i_class_value !== (i_class_value = /*props*/
      ctx2[1] && /*props*/
      ctx2[1]["onfalse"] && /*props*/
      ctx2[1]["onfalse"].iconClass ? (
        /*props*/
        ctx2[1]["onfalse"].iconClass
      ) : (
        /*defaultProps*/
        ctx2[2]["onfalse"].iconClass
      ))) {
        attr_dev(i, "class", i_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(i);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_14.name,
    type: "else",
    source: "(46:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let i;
  let i_class_value;
  const block = {
    c: function create() {
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", i_class_value = /*props*/
      ctx[1] && /*props*/
      ctx[1]["ontrue"] && /*props*/
      ctx[1]["ontrue"].iconClass ? (
        /*props*/
        ctx[1]["ontrue"].iconClass
      ) : (
        /*defaultProps*/
        ctx[2]["ontrue"].iconClass
      ));
      add_location(i, file7, 40, 4, 1009);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*props*/
      2 && i_class_value !== (i_class_value = /*props*/
      ctx2[1] && /*props*/
      ctx2[1]["ontrue"] && /*props*/
      ctx2[1]["ontrue"].iconClass ? (
        /*props*/
        ctx2[1]["ontrue"].iconClass
      ) : (
        /*defaultProps*/
        ctx2[2]["ontrue"].iconClass
      ))) {
        attr_dev(i, "class", i_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(i);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(40:3) {#if value}",
    ctx
  });
  return block;
}
function create_else_block5(ctx) {
  let span;
  let t_value = (
    /*props*/
    (ctx[1] && /*props*/
    ctx[1]["onfalse"] && /*props*/
    ctx[1]["onfalse"].label ? (
      /*props*/
      ctx[1]["onfalse"].label
    ) : (
      /*defaultProps*/
      ctx[2]["onfalse"].label
    )) + ""
  );
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file7, 61, 3, 1521);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*props*/
      2 && t_value !== (t_value = /*props*/
      (ctx2[1] && /*props*/
      ctx2[1]["onfalse"] && /*props*/
      ctx2[1]["onfalse"].label ? (
        /*props*/
        ctx2[1]["onfalse"].label
      ) : (
        /*defaultProps*/
        ctx2[2]["onfalse"].label
      )) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(61:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let span;
  let t_value = (
    /*props*/
    (ctx[1] && /*props*/
    ctx[1]["ontrue"] && /*props*/
    ctx[1]["ontrue"].label ? (
      /*props*/
      ctx[1]["ontrue"].label
    ) : (
      /*defaultProps*/
      ctx[2]["ontrue"].label
    )) + ""
  );
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file7, 55, 3, 1369);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*props*/
      2 && t_value !== (t_value = /*props*/
      (ctx2[1] && /*props*/
      ctx2[1]["ontrue"] && /*props*/
      ctx2[1]["ontrue"].label ? (
        /*props*/
        ctx2[1]["ontrue"].label
      ) : (
        /*defaultProps*/
        ctx2[2]["ontrue"].label
      )) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(55:2) {#if value}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let td;
  let span1;
  let span0;
  let span0_class_value;
  let t;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*value*/
      ctx2[0]
    )
      return create_if_block_14;
    return create_else_block_14;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block0 = current_block_type(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (
      /*value*/
      ctx2[0]
    )
      return create_if_block5;
    return create_else_block5;
  }
  let current_block_type_1 = select_block_type_1(ctx, -1);
  let if_block1 = current_block_type_1(ctx);
  const block = {
    c: function create() {
      td = element("td");
      span1 = element("span");
      span0 = element("span");
      if_block0.c();
      t = space();
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      span1 = claim_element(td_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      if_block0.l(span0_nodes);
      span0_nodes.forEach(detach_dev);
      t = claim_space(span1_nodes);
      if_block1.l(span1_nodes);
      span1_nodes.forEach(detach_dev);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", span0_class_value = /*value*/
      ctx[0] ? (
        /*props*/
        ctx[1] && /*props*/
        ctx[1]["ontrue"] && /*props*/
        ctx[1]["ontrue"].iconColorClass ? (
          /*props*/
          ctx[1]["ontrue"].iconColorClass + " icon"
        ) : (
          /*defaultProps*/
          ctx[2]["ontrue"].iconColorClass + " icon"
        )
      ) : (
        /*props*/
        ctx[1] && /*props*/
        ctx[1]["onfalse"] && /*props*/
        ctx[1]["onfalse"].iconColorClass ? (
          /*props*/
          ctx[1]["onfalse"].iconColorClass + " icon"
        ) : (
          /*defaultProps*/
          ctx[2]["onfalse"].iconColorClass + " icon"
        )
      ));
      add_location(span0, file7, 30, 2, 625);
      attr_dev(span1, "class", "icon-text");
      add_location(span1, file7, 24, 1, 550);
      attr_dev(td, "class", "has-text-centered");
      add_location(td, file7, 22, 0, 451);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, span1);
      append_hydration_dev(span1, span0);
      if_block0.m(span0, null);
      append_hydration_dev(span1, t);
      if_block1.m(span1, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            span1,
            "click",
            /*click_handler_1*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            td,
            "click",
            /*click_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(span0, null);
        }
      }
      if (dirty & /*value, props*/
      3 && span0_class_value !== (span0_class_value = /*value*/
      ctx2[0] ? (
        /*props*/
        ctx2[1] && /*props*/
        ctx2[1]["ontrue"] && /*props*/
        ctx2[1]["ontrue"].iconColorClass ? (
          /*props*/
          ctx2[1]["ontrue"].iconColorClass + " icon"
        ) : (
          /*defaultProps*/
          ctx2[2]["ontrue"].iconColorClass + " icon"
        )
      ) : (
        /*props*/
        ctx2[1] && /*props*/
        ctx2[1]["onfalse"] && /*props*/
        ctx2[1]["onfalse"].iconColorClass ? (
          /*props*/
          ctx2[1]["onfalse"].iconColorClass + " icon"
        ) : (
          /*defaultProps*/
          ctx2[2]["onfalse"].iconColorClass + " icon"
        )
      ))) {
        attr_dev(span0, "class", span0_class_value);
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type_1(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(span1, null);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      if_block0.d();
      if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BooleanIcon", slots, []);
  "use strict";
  let { value } = $$props;
  const row = {};
  let { props = {} } = $$props;
  let defaultProps = {
    ontrue: {
      label: "true",
      iconClass: "fa-regular fa-square-check",
      iconColorClass: " has-text-success "
    },
    onfalse: {
      label: "false",
      iconClass: "fa-regular fa-square",
      iconColorClass: " has-text-danger "
    }
  };
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<BooleanIcon> was created without expected prop 'value'");
    }
  });
  const writable_props = ["value", "props"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BooleanIcon> was created with unknown prop '${key}'`);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler_1 = () => {
    $$invalidate(0, value = !value);
  };
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
  };
  $$self.$capture_state = () => ({ value, row, props, defaultProps });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
    if ("defaultProps" in $$props2)
      $$invalidate(2, defaultProps = $$props2.defaultProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, props, defaultProps, row, click_handler, click_handler_1];
}
var BooleanIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { value: 0, row: 3, props: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BooleanIcon",
      options,
      id: create_fragment7.name
    });
  }
  get value() {
    throw new Error("<BooleanIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<BooleanIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get row() {
    return this.$$.ctx[3];
  }
  set row(value) {
    throw new Error("<BooleanIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<BooleanIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<BooleanIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BooleanIcon_default = BooleanIcon;

// node_modules/@edwinspire/svelte-components/dist/class/websocket.js
var import_events = __toESM(require_events(), 1);
var storeChangedTables = writable({});
var WebSocketClient = class extends import_events.EventEmitter {
  constructor() {
    super();
    this.websocket;
  }
  connect() {
    let url_wwebsocket = "ws://" + window.location.host + "/websocket";
    if (window.location.protocol.includes("https")) {
      url_wwebsocket = "wss://" + window.location.host + "/websocket";
    }
    console.log("Trying to open a WebSocket connection...", url_wwebsocket);
    this.websocket = new WebSocket(url_wwebsocket);
    this.websocket.onopen = (event) => {
      console.log("Connection opened");
    };
    this.websocket.onclose = (event) => {
      console.log("Connection closed");
      setTimeout(this.connect(), 2e3);
    };
    this.websocket.onmessage = (event) => {
      let data = {};
      try {
        data = JSON.parse(event.data);
      } catch (error) {
        console.error(error);
      }
      if (data && data.topic == "pgNotify" && data.message.channel == "onchange-table") {
        try {
          storeChangedTables.set(JSON.parse(data.message.payload));
        } catch (error) {
          console.error(error);
          storeChangedTables.set({});
        }
      }
    };
    return this.websocket;
  }
};

// node_modules/@edwinspire/svelte-components/dist/class/sha.js
function sha256(s) {
  var chrsz = 8;
  var hexcase = 0;
  function safe_add(x, y) {
    var lsw = (x & 65535) + (y & 65535);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  }
  function S(X, n) {
    return X >>> n | X << 32 - n;
  }
  function R(X, n) {
    return X >>> n;
  }
  function Ch(x, y, z) {
    return x & y ^ ~x & z;
  }
  function Maj(x, y, z) {
    return x & y ^ x & z ^ y & z;
  }
  function Sigma0256(x) {
    return S(x, 2) ^ S(x, 13) ^ S(x, 22);
  }
  function Sigma1256(x) {
    return S(x, 6) ^ S(x, 11) ^ S(x, 25);
  }
  function Gamma0256(x) {
    return S(x, 7) ^ S(x, 18) ^ R(x, 3);
  }
  function Gamma1256(x) {
    return S(x, 17) ^ S(x, 19) ^ R(x, 10);
  }
  function core_sha256(m, l) {
    var K = new Array(
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    );
    var HASH = new Array(
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    );
    var W = new Array(64);
    var a, b, c, d, e, f, g, h, i, j;
    var T1, T2;
    m[l >> 5] |= 128 << 24 - l % 32;
    m[(l + 64 >> 9 << 4) + 15] = l;
    for (var i = 0; i < m.length; i += 16) {
      a = HASH[0];
      b = HASH[1];
      c = HASH[2];
      d = HASH[3];
      e = HASH[4];
      f = HASH[5];
      g = HASH[6];
      h = HASH[7];
      for (var j = 0; j < 64; j++) {
        if (j < 16)
          W[j] = m[j + i];
        else
          W[j] = safe_add(
            safe_add(
              safe_add(Gamma1256(W[j - 2]), W[j - 7]),
              Gamma0256(W[j - 15])
            ),
            W[j - 16]
          );
        T1 = safe_add(
          safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]),
          W[j]
        );
        T2 = safe_add(Sigma0256(a), Maj(a, b, c));
        h = g;
        g = f;
        f = e;
        e = safe_add(d, T1);
        d = c;
        c = b;
        b = a;
        a = safe_add(T1, T2);
      }
      HASH[0] = safe_add(a, HASH[0]);
      HASH[1] = safe_add(b, HASH[1]);
      HASH[2] = safe_add(c, HASH[2]);
      HASH[3] = safe_add(d, HASH[3]);
      HASH[4] = safe_add(e, HASH[4]);
      HASH[5] = safe_add(f, HASH[5]);
      HASH[6] = safe_add(g, HASH[6]);
      HASH[7] = safe_add(h, HASH[7]);
    }
    return HASH;
  }
  function str2binb(str) {
    var bin = Array();
    var mask = (1 << chrsz) - 1;
    for (var i = 0; i < str.length * chrsz; i += chrsz) {
      bin[i >> 5] |= (str.charCodeAt(i / chrsz) & mask) << 24 - i % 32;
    }
    return bin;
  }
  function Utf8Encode(string) {
    string = string.replace(/\r\n/g, "\n");
    var utftext = "";
    for (var n = 0; n < string.length; n++) {
      var c = string.charCodeAt(n);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if (c > 127 && c < 2048) {
        utftext += String.fromCharCode(c >> 6 | 192);
        utftext += String.fromCharCode(c & 63 | 128);
      } else {
        utftext += String.fromCharCode(c >> 12 | 224);
        utftext += String.fromCharCode(c >> 6 & 63 | 128);
        utftext += String.fromCharCode(c & 63 | 128);
      }
    }
    return utftext;
  }
  function binb2hex(binarray) {
    var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
    var str = "";
    for (var i = 0; i < binarray.length * 4; i++) {
      str += hex_tab.charAt(binarray[i >> 2] >> (3 - i % 4) * 8 + 4 & 15) + hex_tab.charAt(binarray[i >> 2] >> (3 - i % 4) * 8 & 15);
    }
    return str;
  }
  s = Utf8Encode(s);
  return binb2hex(core_sha256(str2binb(s), s.length * chrsz));
}

// node_modules/@edwinspire/svelte-components/dist/Level/Level.svelte
var file8 = "node_modules/@edwinspire/svelte-components/dist/Level/Level.svelte";
function add_css4(target) {
  append_styles(target, "svelte-j24471", ".slot_padding.svelte-j24471{margin:0.1em !important}.nav_margin.svelte-j24471{margin:0.25em !important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGV2ZWwuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTRGQywyQkFBYyxDQUNiLE1BQU0sQ0FBRSxLQUFLLENBQUMsVUFDZixDQUNBLHlCQUFZLENBQ1gsTUFBTSxDQUFFLE1BQU0sQ0FBQyxVQUNoQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJMZXZlbC5zdmVsdGUiXX0= */");
}
var get_r01_slot_changes = (dirty) => ({});
var get_r01_slot_context = (ctx) => ({});
var get_r02_slot_changes = (dirty) => ({});
var get_r02_slot_context = (ctx) => ({});
var get_r03_slot_changes = (dirty) => ({});
var get_r03_slot_context = (ctx) => ({});
var get_r04_slot_changes = (dirty) => ({});
var get_r04_slot_context = (ctx) => ({});
var get_r05_slot_changes = (dirty) => ({});
var get_r05_slot_context = (ctx) => ({});
var get_r06_slot_changes = (dirty) => ({});
var get_r06_slot_context = (ctx) => ({});
var get_r07_slot_changes = (dirty) => ({});
var get_r07_slot_context = (ctx) => ({});
var get_r08_slot_changes = (dirty) => ({});
var get_r08_slot_context = (ctx) => ({});
var get_r09_slot_changes = (dirty) => ({});
var get_r09_slot_context = (ctx) => ({});
var get_r10_slot_changes = (dirty) => ({});
var get_r10_slot_context = (ctx) => ({});
var get_l10_slot_changes = (dirty) => ({});
var get_l10_slot_context = (ctx) => ({});
var get_l09_slot_changes = (dirty) => ({});
var get_l09_slot_context = (ctx) => ({});
var get_l08_slot_changes = (dirty) => ({});
var get_l08_slot_context = (ctx) => ({});
var get_l07_slot_changes = (dirty) => ({});
var get_l07_slot_context = (ctx) => ({});
var get_l06_slot_changes = (dirty) => ({});
var get_l06_slot_context = (ctx) => ({});
var get_l05_slot_changes = (dirty) => ({});
var get_l05_slot_context = (ctx) => ({});
var get_l04_slot_changes = (dirty) => ({});
var get_l04_slot_context = (ctx) => ({});
var get_l03_slot_changes = (dirty) => ({});
var get_l03_slot_context = (ctx) => ({});
var get_l02_slot_changes = (dirty) => ({});
var get_l02_slot_context = (ctx) => ({});
var get_l01_slot_changes = (dirty) => ({});
var get_l01_slot_context = (ctx) => ({});
var get_left_slot_changes = (dirty) => ({});
var get_left_slot_context = (ctx) => ({});
function create_if_block_19(ctx) {
  let span;
  let current;
  const l01_slot_template = (
    /*#slots*/
    ctx[2].l01
  );
  const l01_slot = create_slot(
    l01_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_l01_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (l01_slot)
        l01_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (l01_slot)
        l01_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding slot_padding svelte-j24471");
      add_location(span, file8, 15, 6, 327);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (l01_slot) {
        l01_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l01_slot) {
        if (l01_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            l01_slot,
            l01_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              l01_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_l01_slot_changes
            ),
            get_l01_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l01_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l01_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (l01_slot)
        l01_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(15:5) {#if $$slots.l01}",
    ctx
  });
  return block;
}
function create_if_block_18(ctx) {
  let span;
  let current;
  const l02_slot_template = (
    /*#slots*/
    ctx[2].l02
  );
  const l02_slot = create_slot(
    l02_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_l02_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (l02_slot)
        l02_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (l02_slot)
        l02_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 18, 6, 451);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (l02_slot) {
        l02_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l02_slot) {
        if (l02_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            l02_slot,
            l02_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              l02_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_l02_slot_changes
            ),
            get_l02_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l02_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l02_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (l02_slot)
        l02_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(18:5) {#if $$slots.l02}",
    ctx
  });
  return block;
}
function create_if_block_17(ctx) {
  let span;
  let current;
  const l03_slot_template = (
    /*#slots*/
    ctx[2].l03
  );
  const l03_slot = create_slot(
    l03_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_l03_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (l03_slot)
        l03_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (l03_slot)
        l03_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 21, 6, 562);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (l03_slot) {
        l03_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l03_slot) {
        if (l03_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            l03_slot,
            l03_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              l03_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_l03_slot_changes
            ),
            get_l03_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l03_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l03_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (l03_slot)
        l03_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(21:5) {#if $$slots.l03}",
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let span;
  let current;
  const l04_slot_template = (
    /*#slots*/
    ctx[2].l04
  );
  const l04_slot = create_slot(
    l04_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_l04_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (l04_slot)
        l04_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (l04_slot)
        l04_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 24, 6, 673);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (l04_slot) {
        l04_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l04_slot) {
        if (l04_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            l04_slot,
            l04_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              l04_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_l04_slot_changes
            ),
            get_l04_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l04_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l04_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (l04_slot)
        l04_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(24:5) {#if $$slots.l04}",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let span;
  let current;
  const l05_slot_template = (
    /*#slots*/
    ctx[2].l05
  );
  const l05_slot = create_slot(
    l05_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_l05_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (l05_slot)
        l05_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (l05_slot)
        l05_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 27, 6, 784);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (l05_slot) {
        l05_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l05_slot) {
        if (l05_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            l05_slot,
            l05_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              l05_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_l05_slot_changes
            ),
            get_l05_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l05_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l05_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (l05_slot)
        l05_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(27:5) {#if $$slots.l05}",
    ctx
  });
  return block;
}
function create_if_block_142(ctx) {
  let span;
  let current;
  const l06_slot_template = (
    /*#slots*/
    ctx[2].l06
  );
  const l06_slot = create_slot(
    l06_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_l06_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (l06_slot)
        l06_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (l06_slot)
        l06_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 30, 6, 895);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (l06_slot) {
        l06_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l06_slot) {
        if (l06_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            l06_slot,
            l06_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              l06_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_l06_slot_changes
            ),
            get_l06_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l06_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l06_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (l06_slot)
        l06_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_142.name,
    type: "if",
    source: "(30:5) {#if $$slots.l06}",
    ctx
  });
  return block;
}
function create_if_block_132(ctx) {
  let span;
  let current;
  const l07_slot_template = (
    /*#slots*/
    ctx[2].l07
  );
  const l07_slot = create_slot(
    l07_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_l07_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (l07_slot)
        l07_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (l07_slot)
        l07_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 33, 6, 1006);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (l07_slot) {
        l07_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l07_slot) {
        if (l07_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            l07_slot,
            l07_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              l07_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_l07_slot_changes
            ),
            get_l07_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l07_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l07_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (l07_slot)
        l07_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_132.name,
    type: "if",
    source: "(33:5) {#if $$slots.l07}",
    ctx
  });
  return block;
}
function create_if_block_122(ctx) {
  let span;
  let current;
  const l08_slot_template = (
    /*#slots*/
    ctx[2].l08
  );
  const l08_slot = create_slot(
    l08_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_l08_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (l08_slot)
        l08_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (l08_slot)
        l08_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 36, 6, 1117);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (l08_slot) {
        l08_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l08_slot) {
        if (l08_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            l08_slot,
            l08_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              l08_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_l08_slot_changes
            ),
            get_l08_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l08_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l08_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (l08_slot)
        l08_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_122.name,
    type: "if",
    source: "(36:5) {#if $$slots.l08}",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let span;
  let current;
  const l09_slot_template = (
    /*#slots*/
    ctx[2].l09
  );
  const l09_slot = create_slot(
    l09_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_l09_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (l09_slot)
        l09_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (l09_slot)
        l09_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 39, 6, 1228);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (l09_slot) {
        l09_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l09_slot) {
        if (l09_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            l09_slot,
            l09_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              l09_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_l09_slot_changes
            ),
            get_l09_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l09_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l09_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (l09_slot)
        l09_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(39:5) {#if $$slots.l09}",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let span;
  let current;
  const l10_slot_template = (
    /*#slots*/
    ctx[2].l10
  );
  const l10_slot = create_slot(
    l10_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_l10_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (l10_slot)
        l10_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (l10_slot)
        l10_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 42, 6, 1339);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (l10_slot) {
        l10_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l10_slot) {
        if (l10_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            l10_slot,
            l10_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              l10_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_l10_slot_changes
            ),
            get_l10_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l10_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l10_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (l10_slot)
        l10_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(42:5) {#if $$slots.l10}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let if_block9_anchor;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx[0].l01 && create_if_block_19(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    ctx[0].l02 && create_if_block_18(ctx)
  );
  let if_block2 = (
    /*$$slots*/
    ctx[0].l03 && create_if_block_17(ctx)
  );
  let if_block3 = (
    /*$$slots*/
    ctx[0].l04 && create_if_block_16(ctx)
  );
  let if_block4 = (
    /*$$slots*/
    ctx[0].l05 && create_if_block_15(ctx)
  );
  let if_block5 = (
    /*$$slots*/
    ctx[0].l06 && create_if_block_142(ctx)
  );
  let if_block6 = (
    /*$$slots*/
    ctx[0].l07 && create_if_block_132(ctx)
  );
  let if_block7 = (
    /*$$slots*/
    ctx[0].l08 && create_if_block_122(ctx)
  );
  let if_block8 = (
    /*$$slots*/
    ctx[0].l09 && create_if_block_11(ctx)
  );
  let if_block9 = (
    /*$$slots*/
    ctx[0].l10 && create_if_block_10(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      if (if_block5)
        if_block5.c();
      t5 = space();
      if (if_block6)
        if_block6.c();
      t6 = space();
      if (if_block7)
        if_block7.c();
      t7 = space();
      if (if_block8)
        if_block8.c();
      t8 = space();
      if (if_block9)
        if_block9.c();
      if_block9_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      t2 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      t3 = claim_space(nodes);
      if (if_block4)
        if_block4.l(nodes);
      t4 = claim_space(nodes);
      if (if_block5)
        if_block5.l(nodes);
      t5 = claim_space(nodes);
      if (if_block6)
        if_block6.l(nodes);
      t6 = claim_space(nodes);
      if (if_block7)
        if_block7.l(nodes);
      t7 = claim_space(nodes);
      if (if_block8)
        if_block8.l(nodes);
      t8 = claim_space(nodes);
      if (if_block9)
        if_block9.l(nodes);
      if_block9_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_hydration_dev(target, t3, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_hydration_dev(target, t4, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_hydration_dev(target, t5, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert_hydration_dev(target, t6, anchor);
      if (if_block7)
        if_block7.m(target, anchor);
      insert_hydration_dev(target, t7, anchor);
      if (if_block8)
        if_block8.m(target, anchor);
      insert_hydration_dev(target, t8, anchor);
      if (if_block9)
        if_block9.m(target, anchor);
      insert_hydration_dev(target, if_block9_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[0].l01
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_19(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].l02
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_18(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].l03
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_17(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].l04
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_16(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t3.parentNode, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].l05
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_15(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t4.parentNode, t4);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].l06
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_142(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t5.parentNode, t5);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].l07
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_132(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(t6.parentNode, t6);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].l08
      ) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block7, 1);
          }
        } else {
          if_block7 = create_if_block_122(ctx2);
          if_block7.c();
          transition_in(if_block7, 1);
          if_block7.m(t7.parentNode, t7);
        }
      } else if (if_block7) {
        group_outros();
        transition_out(if_block7, 1, 1, () => {
          if_block7 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].l09
      ) {
        if (if_block8) {
          if_block8.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block8, 1);
          }
        } else {
          if_block8 = create_if_block_11(ctx2);
          if_block8.c();
          transition_in(if_block8, 1);
          if_block8.m(t8.parentNode, t8);
        }
      } else if (if_block8) {
        group_outros();
        transition_out(if_block8, 1, 1, () => {
          if_block8 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].l10
      ) {
        if (if_block9) {
          if_block9.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block9, 1);
          }
        } else {
          if_block9 = create_if_block_10(ctx2);
          if_block9.c();
          transition_in(if_block9, 1);
          if_block9.m(if_block9_anchor.parentNode, if_block9_anchor);
        }
      } else if (if_block9) {
        group_outros();
        transition_out(if_block9, 1, 1, () => {
          if_block9 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(if_block6);
      transition_in(if_block7);
      transition_in(if_block8);
      transition_in(if_block9);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(if_block6);
      transition_out(if_block7);
      transition_out(if_block8);
      transition_out(if_block9);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(t5);
        detach_dev(t6);
        detach_dev(t7);
        detach_dev(t8);
        detach_dev(if_block9_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      if (if_block3)
        if_block3.d(detaching);
      if (if_block4)
        if_block4.d(detaching);
      if (if_block5)
        if_block5.d(detaching);
      if (if_block6)
        if_block6.d(detaching);
      if (if_block7)
        if_block7.d(detaching);
      if (if_block8)
        if_block8.d(detaching);
      if (if_block9)
        if_block9.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(14:22)       ",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let span;
  let current;
  const r10_slot_template = (
    /*#slots*/
    ctx[2].r10
  );
  const r10_slot = create_slot(
    r10_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_r10_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (r10_slot)
        r10_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (r10_slot)
        r10_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 57, 5, 1684);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (r10_slot) {
        r10_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (r10_slot) {
        if (r10_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            r10_slot,
            r10_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              r10_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_r10_slot_changes
            ),
            get_r10_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(r10_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(r10_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (r10_slot)
        r10_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(57:4) {#if $$slots.r10}",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let span;
  let current;
  const r09_slot_template = (
    /*#slots*/
    ctx[2].r09
  );
  const r09_slot = create_slot(
    r09_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_r09_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (r09_slot)
        r09_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (r09_slot)
        r09_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 60, 5, 1792);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (r09_slot) {
        r09_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (r09_slot) {
        if (r09_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            r09_slot,
            r09_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              r09_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_r09_slot_changes
            ),
            get_r09_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(r09_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(r09_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (r09_slot)
        r09_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(60:4) {#if $$slots.r09}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let span;
  let current;
  const r08_slot_template = (
    /*#slots*/
    ctx[2].r08
  );
  const r08_slot = create_slot(
    r08_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_r08_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (r08_slot)
        r08_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (r08_slot)
        r08_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 63, 5, 1900);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (r08_slot) {
        r08_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (r08_slot) {
        if (r08_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            r08_slot,
            r08_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              r08_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_r08_slot_changes
            ),
            get_r08_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(r08_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(r08_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (r08_slot)
        r08_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(63:4) {#if $$slots.r08}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let span;
  let current;
  const r07_slot_template = (
    /*#slots*/
    ctx[2].r07
  );
  const r07_slot = create_slot(
    r07_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_r07_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (r07_slot)
        r07_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (r07_slot)
        r07_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 66, 5, 2008);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (r07_slot) {
        r07_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (r07_slot) {
        if (r07_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            r07_slot,
            r07_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              r07_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_r07_slot_changes
            ),
            get_r07_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(r07_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(r07_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (r07_slot)
        r07_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(66:4) {#if $$slots.r07}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let span;
  let current;
  const r06_slot_template = (
    /*#slots*/
    ctx[2].r06
  );
  const r06_slot = create_slot(
    r06_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_r06_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (r06_slot)
        r06_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (r06_slot)
        r06_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 69, 5, 2116);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (r06_slot) {
        r06_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (r06_slot) {
        if (r06_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            r06_slot,
            r06_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              r06_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_r06_slot_changes
            ),
            get_r06_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(r06_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(r06_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (r06_slot)
        r06_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(69:4) {#if $$slots.r06}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let span;
  let current;
  const r05_slot_template = (
    /*#slots*/
    ctx[2].r05
  );
  const r05_slot = create_slot(
    r05_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_r05_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (r05_slot)
        r05_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (r05_slot)
        r05_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 72, 5, 2224);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (r05_slot) {
        r05_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (r05_slot) {
        if (r05_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            r05_slot,
            r05_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              r05_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_r05_slot_changes
            ),
            get_r05_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(r05_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(r05_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (r05_slot)
        r05_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(72:4) {#if $$slots.r05}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let span;
  let current;
  const r04_slot_template = (
    /*#slots*/
    ctx[2].r04
  );
  const r04_slot = create_slot(
    r04_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_r04_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (r04_slot)
        r04_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (r04_slot)
        r04_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 75, 5, 2332);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (r04_slot) {
        r04_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (r04_slot) {
        if (r04_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            r04_slot,
            r04_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              r04_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_r04_slot_changes
            ),
            get_r04_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(r04_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(r04_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (r04_slot)
        r04_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(75:4) {#if $$slots.r04}",
    ctx
  });
  return block;
}
function create_if_block_23(ctx) {
  let span;
  let current;
  const r03_slot_template = (
    /*#slots*/
    ctx[2].r03
  );
  const r03_slot = create_slot(
    r03_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_r03_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (r03_slot)
        r03_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (r03_slot)
        r03_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 78, 5, 2440);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (r03_slot) {
        r03_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (r03_slot) {
        if (r03_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            r03_slot,
            r03_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              r03_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_r03_slot_changes
            ),
            get_r03_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(r03_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(r03_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (r03_slot)
        r03_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(78:4) {#if $$slots.r03}",
    ctx
  });
  return block;
}
function create_if_block_110(ctx) {
  let span;
  let current;
  const r02_slot_template = (
    /*#slots*/
    ctx[2].r02
  );
  const r02_slot = create_slot(
    r02_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_r02_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (r02_slot)
        r02_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (r02_slot)
        r02_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 81, 5, 2548);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (r02_slot) {
        r02_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (r02_slot) {
        if (r02_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            r02_slot,
            r02_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              r02_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_r02_slot_changes
            ),
            get_r02_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(r02_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(r02_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (r02_slot)
        r02_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(81:4) {#if $$slots.r02}",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let span;
  let current;
  const r01_slot_template = (
    /*#slots*/
    ctx[2].r01
  );
  const r01_slot = create_slot(
    r01_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_r01_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (r01_slot)
        r01_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (r01_slot)
        r01_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "column is-narrow slot_padding svelte-j24471");
      add_location(span, file8, 84, 5, 2656);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (r01_slot) {
        r01_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (r01_slot) {
        if (r01_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            r01_slot,
            r01_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              r01_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_r01_slot_changes
            ),
            get_r01_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(r01_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(r01_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (r01_slot)
        r01_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(84:4) {#if $$slots.r01}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let nav;
  let div4;
  let div1;
  let div0;
  let t0;
  let div3;
  let div2;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  let current;
  const left_slot_template = (
    /*#slots*/
    ctx[2].left
  );
  const left_slot = create_slot(
    left_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_left_slot_context
  );
  const left_slot_or_fallback = left_slot || fallback_block(ctx);
  let if_block0 = (
    /*$$slots*/
    ctx[0].r10 && create_if_block_9(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    ctx[0].r09 && create_if_block_8(ctx)
  );
  let if_block2 = (
    /*$$slots*/
    ctx[0].r08 && create_if_block_7(ctx)
  );
  let if_block3 = (
    /*$$slots*/
    ctx[0].r07 && create_if_block_6(ctx)
  );
  let if_block4 = (
    /*$$slots*/
    ctx[0].r06 && create_if_block_5(ctx)
  );
  let if_block5 = (
    /*$$slots*/
    ctx[0].r05 && create_if_block_4(ctx)
  );
  let if_block6 = (
    /*$$slots*/
    ctx[0].r04 && create_if_block_32(ctx)
  );
  let if_block7 = (
    /*$$slots*/
    ctx[0].r03 && create_if_block_23(ctx)
  );
  let if_block8 = (
    /*$$slots*/
    ctx[0].r02 && create_if_block_110(ctx)
  );
  let if_block9 = (
    /*$$slots*/
    ctx[0].r01 && create_if_block6(ctx)
  );
  const block = {
    c: function create() {
      nav = element("nav");
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (left_slot_or_fallback)
        left_slot_or_fallback.c();
      t0 = space();
      div3 = element("div");
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      t6 = space();
      if (if_block6)
        if_block6.c();
      t7 = space();
      if (if_block7)
        if_block7.c();
      t8 = space();
      if (if_block8)
        if_block8.c();
      t9 = space();
      if (if_block9)
        if_block9.c();
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      div4 = claim_element(nav_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div1 = claim_element(div4_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (left_slot_or_fallback)
        left_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t0 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (if_block0)
        if_block0.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      if (if_block1)
        if_block1.l(div2_nodes);
      t2 = claim_space(div2_nodes);
      if (if_block2)
        if_block2.l(div2_nodes);
      t3 = claim_space(div2_nodes);
      if (if_block3)
        if_block3.l(div2_nodes);
      t4 = claim_space(div2_nodes);
      if (if_block4)
        if_block4.l(div2_nodes);
      t5 = claim_space(div2_nodes);
      if (if_block5)
        if_block5.l(div2_nodes);
      t6 = claim_space(div2_nodes);
      if (if_block6)
        if_block6.l(div2_nodes);
      t7 = claim_space(div2_nodes);
      if (if_block7)
        if_block7.l(div2_nodes);
      t8 = claim_space(div2_nodes);
      if (if_block8)
        if_block8.l(div2_nodes);
      t9 = claim_space(div2_nodes);
      if (if_block9)
        if_block9.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "columns is-multiline is-mobile is-gapless");
      add_location(div0, file8, 12, 3, 219);
      attr_dev(div1, "class", "column is-full-mobile is-half-tablet is-half-desktop is-half-widescreen is-half-fullhd");
      add_location(div1, file8, 5, 2, 93);
      attr_dev(div2, "class", "columns is-multiline is-mobile is-gapless is-pulled-right");
      add_location(div2, file8, 55, 3, 1585);
      attr_dev(div3, "class", "column is-full-mobile is-half-tablet is-half-desktop is-half-widescreen is-half-fullhd");
      add_location(div3, file8, 48, 2, 1459);
      attr_dev(div4, "class", "columns is-multiline is-mobile");
      add_location(div4, file8, 4, 1, 46);
      attr_dev(nav, "class", "nav_margin svelte-j24471");
      add_location(nav, file8, 3, 0, 20);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      append_hydration_dev(nav, div4);
      append_hydration_dev(div4, div1);
      append_hydration_dev(div1, div0);
      if (left_slot_or_fallback) {
        left_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(div4, t0);
      append_hydration_dev(div4, div3);
      append_hydration_dev(div3, div2);
      if (if_block0)
        if_block0.m(div2, null);
      append_hydration_dev(div2, t1);
      if (if_block1)
        if_block1.m(div2, null);
      append_hydration_dev(div2, t2);
      if (if_block2)
        if_block2.m(div2, null);
      append_hydration_dev(div2, t3);
      if (if_block3)
        if_block3.m(div2, null);
      append_hydration_dev(div2, t4);
      if (if_block4)
        if_block4.m(div2, null);
      append_hydration_dev(div2, t5);
      if (if_block5)
        if_block5.m(div2, null);
      append_hydration_dev(div2, t6);
      if (if_block6)
        if_block6.m(div2, null);
      append_hydration_dev(div2, t7);
      if (if_block7)
        if_block7.m(div2, null);
      append_hydration_dev(div2, t8);
      if (if_block8)
        if_block8.m(div2, null);
      append_hydration_dev(div2, t9);
      if (if_block9)
        if_block9.m(div2, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (left_slot) {
        if (left_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            left_slot,
            left_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              left_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_left_slot_changes
            ),
            get_left_slot_context
          );
        }
      } else {
        if (left_slot_or_fallback && left_slot_or_fallback.p && (!current || dirty & /*$$scope, $$slots*/
        3)) {
          left_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (
        /*$$slots*/
        ctx2[0].r10
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_9(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].r09
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_8(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].r08
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_7(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].r07
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_6(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div2, t4);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].r06
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_5(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div2, t5);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].r05
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_4(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div2, t6);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].r04
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_32(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(div2, t7);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].r03
      ) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block7, 1);
          }
        } else {
          if_block7 = create_if_block_23(ctx2);
          if_block7.c();
          transition_in(if_block7, 1);
          if_block7.m(div2, t8);
        }
      } else if (if_block7) {
        group_outros();
        transition_out(if_block7, 1, 1, () => {
          if_block7 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].r02
      ) {
        if (if_block8) {
          if_block8.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block8, 1);
          }
        } else {
          if_block8 = create_if_block_110(ctx2);
          if_block8.c();
          transition_in(if_block8, 1);
          if_block8.m(div2, t9);
        }
      } else if (if_block8) {
        group_outros();
        transition_out(if_block8, 1, 1, () => {
          if_block8 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[0].r01
      ) {
        if (if_block9) {
          if_block9.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block9, 1);
          }
        } else {
          if_block9 = create_if_block6(ctx2);
          if_block9.c();
          transition_in(if_block9, 1);
          if_block9.m(div2, null);
        }
      } else if (if_block9) {
        group_outros();
        transition_out(if_block9, 1, 1, () => {
          if_block9 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(left_slot_or_fallback, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(if_block6);
      transition_in(if_block7);
      transition_in(if_block8);
      transition_in(if_block9);
      current = true;
    },
    o: function outro(local) {
      transition_out(left_slot_or_fallback, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(if_block6);
      transition_out(if_block7);
      transition_out(if_block8);
      transition_out(if_block9);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(nav);
      }
      if (left_slot_or_fallback)
        left_slot_or_fallback.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      if (if_block7)
        if_block7.d();
      if (if_block8)
        if_block8.d();
      if (if_block9)
        if_block9.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Level", slots, [
    "l01",
    "l02",
    "l03",
    "l04",
    "l05",
    "l06",
    "l07",
    "l08",
    "l09",
    "l10",
    "left",
    "r10",
    "r09",
    "r08",
    "r07",
    "r06",
    "r05",
    "r04",
    "r03",
    "r02",
    "r01"
  ]);
  const $$slots = compute_slots(slots);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Level> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [$$slots, $$scope, slots];
}
var Level = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {}, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Level",
      options,
      id: create_fragment8.name
    });
  }
};
var Level_default = Level;

// node_modules/@edwinspire/svelte-components/dist/Table/Table.svelte
var { Object: Object_12, console: console_1 } = globals;
var file9 = "node_modules/@edwinspire/svelte-components/dist/Table/Table.svelte";
function add_css5(target) {
  append_styles(target, "svelte-mg5ytk", ".size_search.svelte-mg5ytk{width:7em}.show_cursor_mouse.svelte-mg5ytk{cursor:pointer}.table_pagination.svelte-mg5ytk{width:98%;margin:auto}.label_rows_per_page.svelte-mg5ytk{margin-right:1em}.margin_title.svelte-mg5ytk{margin-left:0.5em}.check_margin.svelte-mg5ytk{margin-left:10px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXdoQ0MsMEJBQWEsQ0FDWixLQUFLLENBQUUsR0FDUixDQUNBLGdDQUFtQixDQUNsQixNQUFNLENBQUUsT0FDVCxDQUVBLCtCQUFrQixDQUNqQixLQUFLLENBQUUsR0FBRyxDQUNWLE1BQU0sQ0FBRSxJQUNULENBQ0Esa0NBQXFCLENBQ3BCLFlBQVksQ0FBRSxHQUNmLENBQ0EsMkJBQWMsQ0FDYixXQUFXLENBQUUsS0FDZCxDQUVBLDJCQUFjLENBQ2IsV0FBVyxDQUFFLElBQ2QiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVGFibGUuc3ZlbHRlIl19 */");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[84] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[87] = list[i];
  child_ctx[89] = i;
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[90] = list[i];
  child_ctx[91] = list;
  child_ctx[92] = i;
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[87] = list[i];
  child_ctx[93] = list;
  child_ctx[89] = i;
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[87] = list[i];
  child_ctx[95] = i;
  return child_ctx;
}
var get_l01_slot_changes2 = (dirty) => ({});
var get_l01_slot_context2 = (ctx) => ({});
var get_l02_slot_changes2 = (dirty) => ({});
var get_l02_slot_context2 = (ctx) => ({});
var get_l03_slot_changes2 = (dirty) => ({});
var get_l03_slot_context2 = (ctx) => ({});
var get_l04_slot_changes2 = (dirty) => ({});
var get_l04_slot_context2 = (ctx) => ({});
var get_l05_slot_changes2 = (dirty) => ({});
var get_l05_slot_context2 = (ctx) => ({});
var get_l06_slot_changes2 = (dirty) => ({});
var get_l06_slot_context2 = (ctx) => ({});
var get_l07_slot_changes2 = (dirty) => ({});
var get_l07_slot_context2 = (ctx) => ({});
var get_l08_slot_changes2 = (dirty) => ({});
var get_l08_slot_context2 = (ctx) => ({});
var get_l09_slot_changes2 = (dirty) => ({});
var get_l09_slot_context2 = (ctx) => ({});
var get_l10_slot_changes2 = (dirty) => ({});
var get_l10_slot_context2 = (ctx) => ({});
var get_r07_slot_changes2 = (dirty) => ({});
var get_r07_slot_context2 = (ctx) => ({});
var get_r08_slot_changes2 = (dirty) => ({});
var get_r08_slot_context2 = (ctx) => ({});
var get_r09_slot_changes2 = (dirty) => ({});
var get_r09_slot_context2 = (ctx) => ({});
var get_r10_slot_changes2 = (dirty) => ({});
var get_r10_slot_context2 = (ctx) => ({});
function create_if_block_41(ctx) {
  let current;
  const l01_slot_template = (
    /*#slots*/
    ctx[46].l01
  );
  const l01_slot = create_slot(
    l01_slot_template,
    ctx,
    /*$$scope*/
    ctx[69],
    get_l01_slot_context2
  );
  const block = {
    c: function create() {
      if (l01_slot)
        l01_slot.c();
    },
    l: function claim(nodes) {
      if (l01_slot)
        l01_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (l01_slot) {
        l01_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l01_slot) {
        if (l01_slot.p && (!current || dirty[2] & /*$$scope*/
        128)) {
          update_slot_base(
            l01_slot,
            l01_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[69],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[69]
            ) : get_slot_changes(
              l01_slot_template,
              /*$$scope*/
              ctx2[69],
              dirty,
              get_l01_slot_changes2
            ),
            get_l01_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l01_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l01_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (l01_slot)
        l01_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_41.name,
    type: "if",
    source: "(528:2) {#if $$slots.l01}",
    ctx
  });
  return block;
}
function create_l01_slot(ctx) {
  let span;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[38].l01 && create_if_block_41(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "l01");
      add_location(span, file9, 526, 1, 13545);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[38].l01
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_41(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_l01_slot.name,
    type: "slot",
    source: "(527:1) ",
    ctx
  });
  return block;
}
function create_if_block_40(ctx) {
  let current;
  const l02_slot_template = (
    /*#slots*/
    ctx[46].l02
  );
  const l02_slot = create_slot(
    l02_slot_template,
    ctx,
    /*$$scope*/
    ctx[69],
    get_l02_slot_context2
  );
  const block = {
    c: function create() {
      if (l02_slot)
        l02_slot.c();
    },
    l: function claim(nodes) {
      if (l02_slot)
        l02_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (l02_slot) {
        l02_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l02_slot) {
        if (l02_slot.p && (!current || dirty[2] & /*$$scope*/
        128)) {
          update_slot_base(
            l02_slot,
            l02_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[69],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[69]
            ) : get_slot_changes(
              l02_slot_template,
              /*$$scope*/
              ctx2[69],
              dirty,
              get_l02_slot_changes2
            ),
            get_l02_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l02_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l02_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (l02_slot)
        l02_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_40.name,
    type: "if",
    source: "(533:2) {#if $$slots.l02}",
    ctx
  });
  return block;
}
function create_l02_slot(ctx) {
  let span;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[38].l02 && create_if_block_40(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "l02");
      add_location(span, file9, 531, 1, 13624);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[38].l02
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_40(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_l02_slot.name,
    type: "slot",
    source: "(532:1) ",
    ctx
  });
  return block;
}
function create_if_block_39(ctx) {
  let current;
  const l03_slot_template = (
    /*#slots*/
    ctx[46].l03
  );
  const l03_slot = create_slot(
    l03_slot_template,
    ctx,
    /*$$scope*/
    ctx[69],
    get_l03_slot_context2
  );
  const block = {
    c: function create() {
      if (l03_slot)
        l03_slot.c();
    },
    l: function claim(nodes) {
      if (l03_slot)
        l03_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (l03_slot) {
        l03_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l03_slot) {
        if (l03_slot.p && (!current || dirty[2] & /*$$scope*/
        128)) {
          update_slot_base(
            l03_slot,
            l03_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[69],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[69]
            ) : get_slot_changes(
              l03_slot_template,
              /*$$scope*/
              ctx2[69],
              dirty,
              get_l03_slot_changes2
            ),
            get_l03_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l03_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l03_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (l03_slot)
        l03_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_39.name,
    type: "if",
    source: "(538:2) {#if $$slots.l03}",
    ctx
  });
  return block;
}
function create_l03_slot(ctx) {
  let span;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[38].l03 && create_if_block_39(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "l03");
      add_location(span, file9, 536, 1, 13703);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[38].l03
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_39(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_l03_slot.name,
    type: "slot",
    source: "(537:1) ",
    ctx
  });
  return block;
}
function create_if_block_38(ctx) {
  let current;
  const l04_slot_template = (
    /*#slots*/
    ctx[46].l04
  );
  const l04_slot = create_slot(
    l04_slot_template,
    ctx,
    /*$$scope*/
    ctx[69],
    get_l04_slot_context2
  );
  const block = {
    c: function create() {
      if (l04_slot)
        l04_slot.c();
    },
    l: function claim(nodes) {
      if (l04_slot)
        l04_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (l04_slot) {
        l04_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l04_slot) {
        if (l04_slot.p && (!current || dirty[2] & /*$$scope*/
        128)) {
          update_slot_base(
            l04_slot,
            l04_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[69],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[69]
            ) : get_slot_changes(
              l04_slot_template,
              /*$$scope*/
              ctx2[69],
              dirty,
              get_l04_slot_changes2
            ),
            get_l04_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l04_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l04_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (l04_slot)
        l04_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_38.name,
    type: "if",
    source: "(543:2) {#if $$slots.l04}",
    ctx
  });
  return block;
}
function create_l04_slot(ctx) {
  let span;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[38].l04 && create_if_block_38(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "l04");
      add_location(span, file9, 541, 1, 13782);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[38].l04
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_38(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_l04_slot.name,
    type: "slot",
    source: "(542:1) ",
    ctx
  });
  return block;
}
function create_if_block_37(ctx) {
  let current;
  const l05_slot_template = (
    /*#slots*/
    ctx[46].l05
  );
  const l05_slot = create_slot(
    l05_slot_template,
    ctx,
    /*$$scope*/
    ctx[69],
    get_l05_slot_context2
  );
  const block = {
    c: function create() {
      if (l05_slot)
        l05_slot.c();
    },
    l: function claim(nodes) {
      if (l05_slot)
        l05_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (l05_slot) {
        l05_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l05_slot) {
        if (l05_slot.p && (!current || dirty[2] & /*$$scope*/
        128)) {
          update_slot_base(
            l05_slot,
            l05_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[69],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[69]
            ) : get_slot_changes(
              l05_slot_template,
              /*$$scope*/
              ctx2[69],
              dirty,
              get_l05_slot_changes2
            ),
            get_l05_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l05_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l05_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (l05_slot)
        l05_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_37.name,
    type: "if",
    source: "(548:2) {#if $$slots.l05}",
    ctx
  });
  return block;
}
function create_l05_slot(ctx) {
  let span;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[38].l05 && create_if_block_37(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "l05");
      add_location(span, file9, 546, 1, 13861);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[38].l05
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_37(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_l05_slot.name,
    type: "slot",
    source: "(547:1) ",
    ctx
  });
  return block;
}
function create_if_block_36(ctx) {
  let current;
  const l06_slot_template = (
    /*#slots*/
    ctx[46].l06
  );
  const l06_slot = create_slot(
    l06_slot_template,
    ctx,
    /*$$scope*/
    ctx[69],
    get_l06_slot_context2
  );
  const block = {
    c: function create() {
      if (l06_slot)
        l06_slot.c();
    },
    l: function claim(nodes) {
      if (l06_slot)
        l06_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (l06_slot) {
        l06_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l06_slot) {
        if (l06_slot.p && (!current || dirty[2] & /*$$scope*/
        128)) {
          update_slot_base(
            l06_slot,
            l06_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[69],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[69]
            ) : get_slot_changes(
              l06_slot_template,
              /*$$scope*/
              ctx2[69],
              dirty,
              get_l06_slot_changes2
            ),
            get_l06_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l06_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l06_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (l06_slot)
        l06_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_36.name,
    type: "if",
    source: "(553:2) {#if $$slots.l06}",
    ctx
  });
  return block;
}
function create_l06_slot(ctx) {
  let span;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[38].l06 && create_if_block_36(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "l06");
      add_location(span, file9, 551, 1, 13940);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[38].l06
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_36(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_l06_slot.name,
    type: "slot",
    source: "(552:1) ",
    ctx
  });
  return block;
}
function create_if_block_35(ctx) {
  let current;
  const l07_slot_template = (
    /*#slots*/
    ctx[46].l07
  );
  const l07_slot = create_slot(
    l07_slot_template,
    ctx,
    /*$$scope*/
    ctx[69],
    get_l07_slot_context2
  );
  const block = {
    c: function create() {
      if (l07_slot)
        l07_slot.c();
    },
    l: function claim(nodes) {
      if (l07_slot)
        l07_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (l07_slot) {
        l07_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l07_slot) {
        if (l07_slot.p && (!current || dirty[2] & /*$$scope*/
        128)) {
          update_slot_base(
            l07_slot,
            l07_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[69],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[69]
            ) : get_slot_changes(
              l07_slot_template,
              /*$$scope*/
              ctx2[69],
              dirty,
              get_l07_slot_changes2
            ),
            get_l07_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l07_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l07_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (l07_slot)
        l07_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_35.name,
    type: "if",
    source: "(558:2) {#if $$slots.l07}",
    ctx
  });
  return block;
}
function create_l07_slot(ctx) {
  let span;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[38].l07 && create_if_block_35(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "l07");
      add_location(span, file9, 556, 1, 14019);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[38].l07
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_35(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_l07_slot.name,
    type: "slot",
    source: "(557:1) ",
    ctx
  });
  return block;
}
function create_if_block_34(ctx) {
  let current;
  const l08_slot_template = (
    /*#slots*/
    ctx[46].l08
  );
  const l08_slot = create_slot(
    l08_slot_template,
    ctx,
    /*$$scope*/
    ctx[69],
    get_l08_slot_context2
  );
  const block = {
    c: function create() {
      if (l08_slot)
        l08_slot.c();
    },
    l: function claim(nodes) {
      if (l08_slot)
        l08_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (l08_slot) {
        l08_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l08_slot) {
        if (l08_slot.p && (!current || dirty[2] & /*$$scope*/
        128)) {
          update_slot_base(
            l08_slot,
            l08_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[69],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[69]
            ) : get_slot_changes(
              l08_slot_template,
              /*$$scope*/
              ctx2[69],
              dirty,
              get_l08_slot_changes2
            ),
            get_l08_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l08_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l08_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (l08_slot)
        l08_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(563:2) {#if $$slots.l08}",
    ctx
  });
  return block;
}
function create_l08_slot(ctx) {
  let span;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[38].l08 && create_if_block_34(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "l08");
      add_location(span, file9, 561, 1, 14098);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[38].l08
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_34(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_l08_slot.name,
    type: "slot",
    source: "(562:1) ",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let current;
  const l09_slot_template = (
    /*#slots*/
    ctx[46].l09
  );
  const l09_slot = create_slot(
    l09_slot_template,
    ctx,
    /*$$scope*/
    ctx[69],
    get_l09_slot_context2
  );
  const block = {
    c: function create() {
      if (l09_slot)
        l09_slot.c();
    },
    l: function claim(nodes) {
      if (l09_slot)
        l09_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (l09_slot) {
        l09_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l09_slot) {
        if (l09_slot.p && (!current || dirty[2] & /*$$scope*/
        128)) {
          update_slot_base(
            l09_slot,
            l09_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[69],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[69]
            ) : get_slot_changes(
              l09_slot_template,
              /*$$scope*/
              ctx2[69],
              dirty,
              get_l09_slot_changes2
            ),
            get_l09_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l09_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l09_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (l09_slot)
        l09_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(568:2) {#if $$slots.l09}",
    ctx
  });
  return block;
}
function create_l09_slot(ctx) {
  let span;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[38].l09 && create_if_block_33(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "l09");
      add_location(span, file9, 566, 1, 14177);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[38].l09
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_33(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_l09_slot.name,
    type: "slot",
    source: "(567:1) ",
    ctx
  });
  return block;
}
function create_if_block_322(ctx) {
  let current;
  const l10_slot_template = (
    /*#slots*/
    ctx[46].l10
  );
  const l10_slot = create_slot(
    l10_slot_template,
    ctx,
    /*$$scope*/
    ctx[69],
    get_l10_slot_context2
  );
  const block = {
    c: function create() {
      if (l10_slot)
        l10_slot.c();
    },
    l: function claim(nodes) {
      if (l10_slot)
        l10_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (l10_slot) {
        l10_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (l10_slot) {
        if (l10_slot.p && (!current || dirty[2] & /*$$scope*/
        128)) {
          update_slot_base(
            l10_slot,
            l10_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[69],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[69]
            ) : get_slot_changes(
              l10_slot_template,
              /*$$scope*/
              ctx2[69],
              dirty,
              get_l10_slot_changes2
            ),
            get_l10_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(l10_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(l10_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (l10_slot)
        l10_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_322.name,
    type: "if",
    source: "(573:2) {#if $$slots.l10}",
    ctx
  });
  return block;
}
function create_l10_slot(ctx) {
  let span;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[38].l10 && create_if_block_322(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "l10");
      add_location(span, file9, 571, 1, 14256);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[38].l10
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_322(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_l10_slot.name,
    type: "slot",
    source: "(572:1) ",
    ctx
  });
  return block;
}
function create_r01_slot(ctx) {
  let span;
  let div;
  let p0;
  let input;
  let t;
  let p1;
  let button;
  let i;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      span = element("span");
      div = element("div");
      p0 = element("p");
      input = element("input");
      t = space();
      p1 = element("p");
      button = element("button");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      div = claim_element(span_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      p0 = claim_element(div_nodes, "P", { class: true });
      var p0_nodes = children(p0);
      input = claim_element(p0_nodes, "INPUT", {
        class: true,
        type: true,
        placeholder: true
      });
      p0_nodes.forEach(detach_dev);
      t = claim_space(div_nodes);
      p1 = claim_element(div_nodes, "P", { class: true });
      var p1_nodes = children(p1);
      button = claim_element(p1_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      i = claim_element(button_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      p1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", "input size_search is-small svelte-mg5ytk");
      attr_dev(input, "type", "text");
      attr_dev(input, "placeholder", "Buscar");
      add_location(input, file9, 580, 4, 14414);
      attr_dev(p0, "class", "control");
      add_location(p0, file9, 579, 3, 14390);
      attr_dev(i, "class", "fas fa-search");
      add_location(i, file9, 589, 5, 14643);
      attr_dev(button, "class", "button is-small");
      add_location(button, file9, 588, 4, 14576);
      attr_dev(p1, "class", "control");
      add_location(p1, file9, 587, 3, 14552);
      attr_dev(div, "class", "field has-addons");
      add_location(div, file9, 578, 2, 14356);
      attr_dev(span, "slot", "r01");
      add_location(span, file9, 577, 1, 14336);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, div);
      append_hydration_dev(div, p0);
      append_hydration_dev(p0, input);
      set_input_value(
        input,
        /*text_search*/
        ctx[12]
      );
      append_hydration_dev(div, t);
      append_hydration_dev(div, p1);
      append_hydration_dev(p1, button);
      append_hydration_dev(button, i);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[50]
          ),
          listen_dev(
            button,
            "click",
            /*handleClickSearch*/
            ctx[31],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*text_search*/
      4096 && input.value !== /*text_search*/
      ctx2[12]) {
        set_input_value(
          input,
          /*text_search*/
          ctx2[12]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_r01_slot.name,
    type: "slot",
    source: "(578:1) ",
    ctx
  });
  return block;
}
function create_if_block_31(ctx) {
  let button;
  let span;
  let i;
  let i_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      span = element("span");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      i = claim_element(span_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", i_class_value = null_to_empty(
        /*iconExport*/
        ctx[8]
      ) + " svelte-mg5ytk");
      add_location(i, file9, 598, 5, 14853);
      attr_dev(span, "class", "icon");
      add_location(span, file9, 597, 4, 14828);
      attr_dev(button, "class", "button is-small");
      add_location(button, file9, 596, 3, 14758);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, span);
      append_hydration_dev(span, i);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*handleExportSelection*/
          ctx[33],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*iconExport*/
      256 && i_class_value !== (i_class_value = null_to_empty(
        /*iconExport*/
        ctx2[8]
      ) + " svelte-mg5ytk")) {
        attr_dev(i, "class", i_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_31.name,
    type: "if",
    source: "(596:2) {#if ShowExportButton}",
    ctx
  });
  return block;
}
function create_r02_slot(ctx) {
  let span;
  let if_block = (
    /*ShowExportButton*/
    ctx[7] && create_if_block_31(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "r02");
      add_location(span, file9, 594, 1, 14712);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*ShowExportButton*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_31(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_r02_slot.name,
    type: "slot",
    source: "(595:1) ",
    ctx
  });
  return block;
}
function create_if_block_30(ctx) {
  let div3;
  let div0;
  let button;
  let span0;
  let i0;
  let t0;
  let div2;
  let div1;
  let a0;
  let input0;
  let t1;
  let span1;
  let i1;
  let t2;
  let span2;
  let textContent = "Simple";
  let t4;
  let a1;
  let input1;
  let t5;
  let span3;
  let i2;
  let t6;
  let span4;
  let textContent_1 = "Multiple";
  let t8;
  let hr;
  let t9;
  let a2;
  let input2;
  let t10;
  let span5;
  let i3;
  let t11;
  let span6;
  let textContent_2 = "Ninguno";
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      button = element("button");
      span0 = element("span");
      i0 = element("i");
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      a0 = element("a");
      input0 = element("input");
      t1 = space();
      span1 = element("span");
      i1 = element("i");
      t2 = space();
      span2 = element("span");
      span2.textContent = textContent;
      t4 = space();
      a1 = element("a");
      input1 = element("input");
      t5 = space();
      span3 = element("span");
      i2 = element("i");
      t6 = space();
      span4 = element("span");
      span4.textContent = textContent_1;
      t8 = space();
      hr = element("hr");
      t9 = space();
      a2 = element("a");
      input2 = element("input");
      t10 = space();
      span5 = element("span");
      i3 = element("i");
      t11 = space();
      span6 = element("span");
      span6.textContent = textContent_2;
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      button = claim_element(div0_nodes, "BUTTON", {
        class: true,
        "aria-haspopup": true,
        "aria-controls": true
      });
      var button_nodes = children(button);
      span0 = claim_element(button_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      i0 = claim_element(span0_nodes, "I", { class: true });
      children(i0).forEach(detach_dev);
      span0_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true, role: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      a0 = claim_element(div1_nodes, "A", { class: true });
      var a0_nodes = children(a0);
      input0 = claim_element(a0_nodes, "INPUT", { class: true, type: true, name: true });
      t1 = claim_space(a0_nodes);
      span1 = claim_element(a0_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      i1 = claim_element(span1_nodes, "I", { class: true });
      children(i1).forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      t2 = claim_space(a0_nodes);
      span2 = claim_element(a0_nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span2) !== "svelte-19l2vqo")
        span2.textContent = textContent;
      a0_nodes.forEach(detach_dev);
      t4 = claim_space(div1_nodes);
      a1 = claim_element(div1_nodes, "A", { class: true });
      var a1_nodes = children(a1);
      input1 = claim_element(a1_nodes, "INPUT", { class: true, type: true, name: true });
      t5 = claim_space(a1_nodes);
      span3 = claim_element(a1_nodes, "SPAN", { class: true });
      var span3_nodes = children(span3);
      i2 = claim_element(span3_nodes, "I", { class: true });
      children(i2).forEach(detach_dev);
      span3_nodes.forEach(detach_dev);
      t6 = claim_space(a1_nodes);
      span4 = claim_element(a1_nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span4) !== "svelte-102nmvq")
        span4.textContent = textContent_1;
      a1_nodes.forEach(detach_dev);
      t8 = claim_space(div1_nodes);
      hr = claim_element(div1_nodes, "HR", { class: true });
      t9 = claim_space(div1_nodes);
      a2 = claim_element(div1_nodes, "A", { class: true });
      var a2_nodes = children(a2);
      input2 = claim_element(a2_nodes, "INPUT", { class: true, type: true, name: true });
      t10 = claim_space(a2_nodes);
      span5 = claim_element(a2_nodes, "SPAN", { class: true });
      var span5_nodes = children(span5);
      i3 = claim_element(span5_nodes, "I", { class: true });
      children(i3).forEach(detach_dev);
      span5_nodes.forEach(detach_dev);
      t11 = claim_space(a2_nodes);
      span6 = claim_element(a2_nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span6) !== "svelte-1w4qbnc")
        span6.textContent = textContent_2;
      a2_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i0, "class", "far fa-list-alt");
      add_location(i0, file9, 609, 7, 15172);
      attr_dev(span0, "class", "icon");
      add_location(span0, file9, 608, 6, 15145);
      attr_dev(button, "class", "button is-small");
      attr_dev(button, "aria-haspopup", "true");
      attr_dev(button, "aria-controls", "dropdown-menu");
      add_location(button, file9, 607, 5, 15055);
      attr_dev(div0, "class", "dropdown-trigger");
      add_location(div0, file9, 606, 4, 15019);
      attr_dev(input0, "class", "check_margin svelte-mg5ytk");
      attr_dev(input0, "type", "radio");
      attr_dev(input0, "name", "selection_type");
      input0.value = "1";
      input0.checked = true;
      add_location(input0, file9, 617, 7, 15423);
      attr_dev(i1, "class", "fas fa-check");
      add_location(i1, file9, 628, 8, 15655);
      attr_dev(span1, "class", "icon");
      add_location(span1, file9, 627, 7, 15627);
      add_location(span2, file9, 630, 7, 15704);
      attr_dev(a0, "class", "dropdown-item is-size-7");
      add_location(a0, file9, 616, 6, 15380);
      attr_dev(input1, "class", "check_margin svelte-mg5ytk");
      attr_dev(input1, "type", "radio");
      attr_dev(input1, "name", "selection_type");
      input1.value = "2";
      input1.checked = true;
      add_location(input1, file9, 635, 7, 15837);
      attr_dev(i2, "class", "fas fa-check-double");
      add_location(i2, file9, 646, 8, 16069);
      attr_dev(span3, "class", "icon");
      add_location(span3, file9, 645, 7, 16041);
      add_location(span4, file9, 648, 7, 16125);
      attr_dev(a1, "class", "dropdown-item is-size-7");
      add_location(a1, file9, 634, 6, 15794);
      attr_dev(hr, "class", "dropdown-divider");
      add_location(hr, file9, 650, 6, 16164);
      attr_dev(input2, "class", "check_margin svelte-mg5ytk");
      attr_dev(input2, "type", "radio");
      attr_dev(input2, "name", "selection_type");
      input2.value = "0";
      input2.checked = true;
      add_location(input2, file9, 653, 7, 16297);
      attr_dev(i3, "class", "fas fa-ban");
      add_location(i3, file9, 665, 8, 16530);
      attr_dev(span5, "class", "icon");
      add_location(span5, file9, 664, 7, 16502);
      add_location(span6, file9, 667, 7, 16577);
      attr_dev(a2, "class", "dropdown-item is-size-7");
      add_location(a2, file9, 652, 6, 16254);
      attr_dev(div1, "class", "dropdown-content");
      add_location(div1, file9, 614, 5, 15291);
      attr_dev(div2, "class", "dropdown-menu");
      attr_dev(div2, "role", "menu");
      add_location(div2, file9, 613, 4, 15246);
      attr_dev(div3, "class", "dropdown is-hoverable is-right");
      add_location(div3, file9, 605, 3, 14970);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div0, button);
      append_hydration_dev(button, span0);
      append_hydration_dev(span0, i0);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, a0);
      append_hydration_dev(a0, input0);
      append_hydration_dev(a0, t1);
      append_hydration_dev(a0, span1);
      append_hydration_dev(span1, i1);
      append_hydration_dev(a0, t2);
      append_hydration_dev(a0, span2);
      append_hydration_dev(div1, t4);
      append_hydration_dev(div1, a1);
      append_hydration_dev(a1, input1);
      append_hydration_dev(a1, t5);
      append_hydration_dev(a1, span3);
      append_hydration_dev(span3, i2);
      append_hydration_dev(a1, t6);
      append_hydration_dev(a1, span4);
      append_hydration_dev(div1, t8);
      append_hydration_dev(div1, hr);
      append_hydration_dev(div1, t9);
      append_hydration_dev(div1, a2);
      append_hydration_dev(a2, input2);
      append_hydration_dev(a2, t10);
      append_hydration_dev(a2, span5);
      append_hydration_dev(span5, i3);
      append_hydration_dev(a2, t11);
      append_hydration_dev(a2, span6);
      if (!mounted) {
        dispose = [
          listen_dev(
            input0,
            "change",
            /*change_handler*/
            ctx[47],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input1,
            "change",
            /*change_handler_1*/
            ctx[48],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input2,
            "change",
            /*change_handler_2*/
            ctx[49],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_30.name,
    type: "if",
    source: "(605:2) {#if ShowSelectionButton}",
    ctx
  });
  return block;
}
function create_r03_slot(ctx) {
  let span;
  let if_block = (
    /*ShowSelectionButton*/
    ctx[6] && create_if_block_30(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "r03");
      add_location(span, file9, 603, 1, 14921);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*ShowSelectionButton*/
        ctx2[6]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_30(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_r03_slot.name,
    type: "slot",
    source: "(604:1) ",
    ctx
  });
  return block;
}
function create_if_block_29(ctx) {
  let button;
  let span;
  let i;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      span = element("span");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      i = claim_element(span_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", "far fa-edit");
      add_location(i, file9, 678, 5, 16810);
      attr_dev(span, "class", "icon");
      add_location(span, file9, 677, 4, 16785);
      attr_dev(button, "class", "button is-small");
      add_location(button, file9, 676, 3, 16719);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, span);
      append_hydration_dev(span, i);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*HandleOnClickEdit*/
          ctx[36],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_29.name,
    type: "if",
    source: "(676:2) {#if ShowEditButton}",
    ctx
  });
  return block;
}
function create_r04_slot(ctx) {
  let span;
  let if_block = (
    /*ShowEditButton*/
    ctx[5] && create_if_block_29(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true, title: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "r04");
      attr_dev(span, "title", "Editar");
      add_location(span, file9, 674, 1, 16660);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*ShowEditButton*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_29(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_r04_slot.name,
    type: "slot",
    source: "(675:1) ",
    ctx
  });
  return block;
}
function create_if_block_28(ctx) {
  let button;
  let span;
  let i;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      span = element("span");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      i = claim_element(span_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", "far fa-file");
      add_location(i, file9, 687, 5, 17026);
      attr_dev(span, "class", "icon");
      add_location(span, file9, 686, 4, 17001);
      attr_dev(button, "class", "button is-small");
      add_location(button, file9, 685, 3, 16943);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, span);
      append_hydration_dev(span, i);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*HClickNew*/
          ctx[29],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_28.name,
    type: "if",
    source: "(685:2) {#if ShowNewButton}",
    ctx
  });
  return block;
}
function create_r05_slot(ctx) {
  let span;
  let if_block = (
    /*ShowNewButton*/
    ctx[4] && create_if_block_28(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true, title: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "r05");
      attr_dev(span, "title", "Agregar fila");
      add_location(span, file9, 683, 1, 16879);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*ShowNewButton*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_28(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_r05_slot.name,
    type: "slot",
    source: "(684:1) ",
    ctx
  });
  return block;
}
function create_if_block_25(ctx) {
  let button;
  let t0;
  let span;
  let t1;
  let t2;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*loading*/
      ctx2[13]
    )
      return create_if_block_26;
    if (
      /*LastFetchResponse*/
      ctx2[18]
    )
      return create_if_block_27;
    return create_else_block_3;
  }
  let current_block_type = select_block_type(ctx, [-1, -1, -1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      button = element("button");
      if_block.c();
      t0 = space();
      span = element("span");
      t1 = text(
        /*timeRemainingToRefresh*/
        ctx[17]
      );
      t2 = text("s");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      if_block.l(button_nodes);
      t0 = claim_space(button_nodes);
      span = claim_element(button_nodes, "SPAN", {});
      var span_nodes = children(span);
      t1 = claim_text(
        span_nodes,
        /*timeRemainingToRefresh*/
        ctx[17]
      );
      t2 = claim_text(span_nodes, "s");
      span_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file9, 702, 4, 17540);
      attr_dev(button, "class", "button is-small");
      add_location(button, file9, 694, 3, 17158);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if_block.m(button, null);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, span);
      append_hydration_dev(span, t1);
      append_hydration_dev(span, t2);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*ChangeIntervalRefresh*/
          ctx[26],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(button, t0);
        }
      }
      if (dirty[0] & /*timeRemainingToRefresh*/
      131072)
        set_data_dev(
          t1,
          /*timeRemainingToRefresh*/
          ctx2[17]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(694:2) {#if url}",
    ctx
  });
  return block;
}
function create_else_block_3(ctx) {
  let span;
  let i;
  const block = {
    c: function create() {
      span = element("span");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      i = claim_element(span_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", "fas fa-exclamation-triangle");
      add_location(i, file9, 700, 40, 17477);
      attr_dev(span, "class", "icon has-text-danger");
      add_location(span, file9, 700, 5, 17442);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, i);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_3.name,
    type: "else",
    source: "(700:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_27(ctx) {
  let span;
  let i;
  const block = {
    c: function create() {
      span = element("span");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      i = claim_element(span_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", "fas fa-hourglass-half");
      add_location(i, file9, 698, 24, 17382);
      attr_dev(span, "class", "icon");
      add_location(span, file9, 698, 5, 17363);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, i);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_27.name,
    type: "if",
    source: "(698:32) ",
    ctx
  });
  return block;
}
function create_if_block_26(ctx) {
  let span;
  let i;
  const block = {
    c: function create() {
      span = element("span");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      i = claim_element(span_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", "fas fa-spinner fa-pulse");
      add_location(i, file9, 696, 38, 17280);
      attr_dev(span, "class", "icon has-text-info");
      add_location(span, file9, 696, 5, 17247);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, i);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_26.name,
    type: "if",
    source: "(696:4) {#if loading}",
    ctx
  });
  return block;
}
function create_r06_slot(ctx) {
  let span;
  let if_block = (
    /*url*/
    ctx[3] && create_if_block_25(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true, title: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "r06");
      attr_dev(span, "title", "Intervalo de refresco");
      add_location(span, file9, 692, 1, 17095);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*url*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_25(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_r06_slot.name,
    type: "slot",
    source: "(693:1) ",
    ctx
  });
  return block;
}
function create_if_block_24(ctx) {
  let current;
  const r07_slot_template = (
    /*#slots*/
    ctx[46].r07
  );
  const r07_slot = create_slot(
    r07_slot_template,
    ctx,
    /*$$scope*/
    ctx[69],
    get_r07_slot_context2
  );
  const block = {
    c: function create() {
      if (r07_slot)
        r07_slot.c();
    },
    l: function claim(nodes) {
      if (r07_slot)
        r07_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (r07_slot) {
        r07_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (r07_slot) {
        if (r07_slot.p && (!current || dirty[2] & /*$$scope*/
        128)) {
          update_slot_base(
            r07_slot,
            r07_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[69],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[69]
            ) : get_slot_changes(
              r07_slot_template,
              /*$$scope*/
              ctx2[69],
              dirty,
              get_r07_slot_changes2
            ),
            get_r07_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(r07_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(r07_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (r07_slot)
        r07_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(708:2) {#if $$slots.r07}",
    ctx
  });
  return block;
}
function create_r07_slot(ctx) {
  let span;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[38].r07 && create_if_block_24(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "r07");
      add_location(span, file9, 706, 1, 17610);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[38].r07
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_24(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_r07_slot.name,
    type: "slot",
    source: "(707:1) ",
    ctx
  });
  return block;
}
function create_if_block_232(ctx) {
  let current;
  const r08_slot_template = (
    /*#slots*/
    ctx[46].r08
  );
  const r08_slot = create_slot(
    r08_slot_template,
    ctx,
    /*$$scope*/
    ctx[69],
    get_r08_slot_context2
  );
  const block = {
    c: function create() {
      if (r08_slot)
        r08_slot.c();
    },
    l: function claim(nodes) {
      if (r08_slot)
        r08_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (r08_slot) {
        r08_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (r08_slot) {
        if (r08_slot.p && (!current || dirty[2] & /*$$scope*/
        128)) {
          update_slot_base(
            r08_slot,
            r08_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[69],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[69]
            ) : get_slot_changes(
              r08_slot_template,
              /*$$scope*/
              ctx2[69],
              dirty,
              get_r08_slot_changes2
            ),
            get_r08_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(r08_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(r08_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (r08_slot)
        r08_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_232.name,
    type: "if",
    source: "(714:2) {#if $$slots.r08}",
    ctx
  });
  return block;
}
function create_r08_slot(ctx) {
  let span;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[38].r08 && create_if_block_232(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "r08");
      add_location(span, file9, 712, 1, 17690);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[38].r08
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_232(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_r08_slot.name,
    type: "slot",
    source: "(713:1) ",
    ctx
  });
  return block;
}
function create_if_block_222(ctx) {
  let current;
  const r09_slot_template = (
    /*#slots*/
    ctx[46].r09
  );
  const r09_slot = create_slot(
    r09_slot_template,
    ctx,
    /*$$scope*/
    ctx[69],
    get_r09_slot_context2
  );
  const block = {
    c: function create() {
      if (r09_slot)
        r09_slot.c();
    },
    l: function claim(nodes) {
      if (r09_slot)
        r09_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (r09_slot) {
        r09_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (r09_slot) {
        if (r09_slot.p && (!current || dirty[2] & /*$$scope*/
        128)) {
          update_slot_base(
            r09_slot,
            r09_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[69],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[69]
            ) : get_slot_changes(
              r09_slot_template,
              /*$$scope*/
              ctx2[69],
              dirty,
              get_r09_slot_changes2
            ),
            get_r09_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(r09_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(r09_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (r09_slot)
        r09_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_222.name,
    type: "if",
    source: "(720:2) {#if $$slots.r09}",
    ctx
  });
  return block;
}
function create_r09_slot(ctx) {
  let span;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[38].r09 && create_if_block_222(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "r09");
      add_location(span, file9, 718, 1, 17770);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[38].r09
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_222(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_r09_slot.name,
    type: "slot",
    source: "(719:1) ",
    ctx
  });
  return block;
}
function create_if_block_21(ctx) {
  let current;
  const r10_slot_template = (
    /*#slots*/
    ctx[46].r10
  );
  const r10_slot = create_slot(
    r10_slot_template,
    ctx,
    /*$$scope*/
    ctx[69],
    get_r10_slot_context2
  );
  const block = {
    c: function create() {
      if (r10_slot)
        r10_slot.c();
    },
    l: function claim(nodes) {
      if (r10_slot)
        r10_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (r10_slot) {
        r10_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (r10_slot) {
        if (r10_slot.p && (!current || dirty[2] & /*$$scope*/
        128)) {
          update_slot_base(
            r10_slot,
            r10_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[69],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[69]
            ) : get_slot_changes(
              r10_slot_template,
              /*$$scope*/
              ctx2[69],
              dirty,
              get_r10_slot_changes2
            ),
            get_r10_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(r10_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(r10_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (r10_slot)
        r10_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_21.name,
    type: "if",
    source: "(726:2) {#if $$slots.r10}",
    ctx
  });
  return block;
}
function create_r10_slot(ctx) {
  let span;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[38].r10 && create_if_block_21(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "r10");
      add_location(span, file9, 724, 1, 17850);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[38].r10
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_21(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_r10_slot.name,
    type: "slot",
    source: "(725:1) ",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let div;
  let i;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      i = element("i");
      t = text("\n		No hay datos que mostrar");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      i = claim_element(div_nodes, "I", { class: true, "aria-hidden": true });
      children(i).forEach(detach_dev);
      t = claim_text(div_nodes, "\n		No hay datos que mostrar");
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", "fa fa-table");
      attr_dev(i, "aria-hidden", "true");
      add_location(i, file9, 996, 2, 25499);
      attr_dev(div, "class", "has-text-centered has-text-link-dark");
      add_location(div, file9, 995, 1, 25446);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, i);
      append_hydration_dev(div, t);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(995:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let div0;
  let table;
  let thead;
  let tr;
  let th;
  let textContent = "#";
  let t1;
  let t2;
  let t3;
  let t4;
  let tbody;
  let t5;
  let div4;
  let nav;
  let div1;
  let t6;
  let div3;
  let span1;
  let span0;
  let textContent_1 = "Filas por página";
  let t8;
  let div2;
  let select;
  let current;
  let mounted;
  let dispose;
  function select_block_type_2(ctx2, dirty) {
    if (
      /*SelectionType*/
      ctx2[0] == 1
    )
      return create_if_block_192;
    if (
      /*SelectionType*/
      ctx2[0] == 2
    )
      return create_if_block_20;
  }
  let current_block_type = select_block_type_2(ctx, [-1, -1, -1, -1]);
  let if_block0 = current_block_type && current_block_type(ctx);
  let if_block1 = (
    /*showEdit*/
    ctx[14] && create_if_block_182(ctx)
  );
  let if_block2 = (
    /*internal_columns*/
    ctx[24] && create_if_block_133(ctx)
  );
  let if_block3 = (
    /*DataTable*/
    ctx[11] && /*DataTable*/
    ctx[11].length > 0 && create_if_block_62(ctx)
  );
  let if_block4 = (
    /*paginatedData*/
    ctx[22] && /*paginatedData*/
    ctx[22].length > 1 && create_if_block_111(ctx)
  );
  let each_value_1 = ensure_array_like_dev(
    /*PageSize*/
    ctx[10]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      div0 = element("div");
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      th = element("th");
      th.textContent = textContent;
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      tbody = element("tbody");
      if (if_block3)
        if_block3.c();
      t5 = space();
      div4 = element("div");
      nav = element("nav");
      div1 = element("div");
      if (if_block4)
        if_block4.c();
      t6 = space();
      div3 = element("div");
      span1 = element("span");
      span0 = element("span");
      span0.textContent = textContent_1;
      t8 = space();
      div2 = element("div");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      table = claim_element(div0_nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      thead = claim_element(table_nodes, "THEAD", {});
      var thead_nodes = children(thead);
      tr = claim_element(thead_nodes, "TR", {});
      var tr_nodes = children(tr);
      th = claim_element(tr_nodes, "TH", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(th) !== "svelte-1kro4cl")
        th.textContent = textContent;
      t1 = claim_space(tr_nodes);
      if (if_block0)
        if_block0.l(tr_nodes);
      t2 = claim_space(tr_nodes);
      if (if_block1)
        if_block1.l(tr_nodes);
      t3 = claim_space(tr_nodes);
      if (if_block2)
        if_block2.l(tr_nodes);
      tr_nodes.forEach(detach_dev);
      thead_nodes.forEach(detach_dev);
      t4 = claim_space(table_nodes);
      tbody = claim_element(table_nodes, "TBODY", {});
      var tbody_nodes = children(tbody);
      if (if_block3)
        if_block3.l(tbody_nodes);
      tbody_nodes.forEach(detach_dev);
      table_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t5 = claim_space(nodes);
      div4 = claim_element(nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      nav = claim_element(div4_nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      div1 = claim_element(nav_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block4)
        if_block4.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t6 = claim_space(nav_nodes);
      div3 = claim_element(nav_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      span1 = claim_element(div3_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span0) !== "svelte-1g07pr1")
        span0.textContent = textContent_1;
      t8 = claim_space(span1_nodes);
      div2 = claim_element(span1_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      select = claim_element(div2_nodes, "SELECT", { name: true });
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th, "class", "has-text-centered");
      add_location(th, file9, 737, 5, 18178);
      add_location(tr, file9, 736, 4, 18168);
      add_location(thead, file9, 735, 3, 18156);
      add_location(tbody, file9, 778, 3, 19387);
      attr_dev(table, "class", "table is-bordered is-striped is-narrow is-hoverable is-fullwidth");
      add_location(table, file9, 733, 2, 18021);
      attr_dev(div0, "class", "table-container is-size-7");
      add_location(div0, file9, 732, 1, 17979);
      attr_dev(div1, "class", "level-left");
      add_location(div1, file9, 861, 3, 22144);
      attr_dev(span0, "class", "label_rows_per_page svelte-mg5ytk");
      add_location(span0, file9, 974, 5, 24898);
      attr_dev(select, "name", "rows_per_page");
      add_location(select, file9, 977, 6, 25043);
      attr_dev(div2, "class", "select is-small");
      add_location(div2, file9, 975, 5, 24961);
      attr_dev(span1, "class", "level-item");
      add_location(span1, file9, 973, 4, 24867);
      attr_dev(div3, "class", "level-right");
      add_location(div3, file9, 972, 3, 24837);
      attr_dev(nav, "class", "level");
      add_location(nav, file9, 859, 2, 22099);
      attr_dev(div4, "class", "table_pagination svelte-mg5ytk");
      add_location(div4, file9, 857, 1, 22040);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      append_hydration_dev(div0, table);
      append_hydration_dev(table, thead);
      append_hydration_dev(thead, tr);
      append_hydration_dev(tr, th);
      append_hydration_dev(tr, t1);
      if (if_block0)
        if_block0.m(tr, null);
      append_hydration_dev(tr, t2);
      if (if_block1)
        if_block1.m(tr, null);
      append_hydration_dev(tr, t3);
      if (if_block2)
        if_block2.m(tr, null);
      append_hydration_dev(table, t4);
      append_hydration_dev(table, tbody);
      if (if_block3)
        if_block3.m(tbody, null);
      insert_hydration_dev(target, t5, anchor);
      insert_hydration_dev(target, div4, anchor);
      append_hydration_dev(div4, nav);
      append_hydration_dev(nav, div1);
      if (if_block4)
        if_block4.m(div1, null);
      append_hydration_dev(nav, t6);
      append_hydration_dev(nav, div3);
      append_hydration_dev(div3, span1);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span1, t8);
      append_hydration_dev(span1, div2);
      append_hydration_dev(div2, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          select,
          "change",
          /*change_handler_3*/
          ctx[66],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if (if_block0)
          if_block0.d(1);
        if_block0 = current_block_type && current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(tr, t2);
        }
      }
      if (
        /*showEdit*/
        ctx2[14]
      ) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_182(ctx2);
          if_block1.c();
          if_block1.m(tr, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*internal_columns*/
        ctx2[24]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_133(ctx2);
          if_block2.c();
          if_block2.m(tr, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*DataTable*/
        ctx2[11] && /*DataTable*/
        ctx2[11].length > 0
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*DataTable*/
          2048) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_62(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(tbody, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*paginatedData*/
        ctx2[22] && /*paginatedData*/
        ctx2[22].length > 1
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_111(ctx2);
          if_block4.c();
          if_block4.m(div1, null);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (dirty[0] & /*PageSize, PageSizeSelected*/
      1026) {
        each_value_1 = ensure_array_like_dev(
          /*PageSize*/
          ctx2[10]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div0);
        detach_dev(t5);
        detach_dev(div4);
      }
      if (if_block0) {
        if_block0.d();
      }
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(732:0) {#if DataTable && DataTable.length > 0}",
    ctx
  });
  return block;
}
function create_if_block_20(ctx) {
  let th;
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      th = element("th");
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true });
      var th_nodes = children(th);
      input = claim_element(th_nodes, "INPUT", { type: true });
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      add_location(input, file9, 742, 7, 18380);
      attr_dev(th, "class", "has-text-centered");
      add_location(th, file9, 741, 6, 18342);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, input);
      if (!mounted) {
        dispose = listen_dev(
          input,
          "click",
          /*handleChangeSelectAll*/
          ctx[32],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_20.name,
    type: "if",
    source: "(741:34) ",
    ctx
  });
  return block;
}
function create_if_block_192(ctx) {
  let th;
  let span;
  let textContent = "-";
  const block = {
    c: function create() {
      th = element("th");
      span = element("span");
      span.textContent = textContent;
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true });
      var th_nodes = children(th);
      span = claim_element(th_nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-1s4sarz")
        span.textContent = textContent;
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file9, 739, 36, 18281);
      attr_dev(th, "class", "has-text-centered");
      add_location(th, file9, 739, 6, 18251);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, span);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_192.name,
    type: "if",
    source: "(739:5) {#if SelectionType == 1}",
    ctx
  });
  return block;
}
function create_if_block_182(ctx) {
  let th;
  let i;
  const block = {
    c: function create() {
      th = element("th");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true });
      var th_nodes = children(th);
      i = claim_element(th_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", "fas fa-pen");
      add_location(i, file9, 748, 7, 18527);
      attr_dev(th, "class", "has-text-centered");
      add_location(th, file9, 747, 6, 18489);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, i);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_182.name,
    type: "if",
    source: "(747:5) {#if showEdit}",
    ctx
  });
  return block;
}
function create_if_block_133(ctx) {
  let each_1_anchor;
  let each_value_4 = ensure_array_like_dev(Object.keys(
    /*internal_columns*/
    ctx[24]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value_4.length; i += 1) {
    each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*internal_columns, HClickHeader, orderASC, ColumnSort*/
      1098940416) {
        each_value_4 = ensure_array_like_dev(Object.keys(
          /*internal_columns*/
          ctx2[24]
        ));
        let i;
        for (i = 0; i < each_value_4.length; i += 1) {
          const child_ctx = get_each_context_4(ctx2, each_value_4, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_4.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_133.name,
    type: "if",
    source: "(753:5) {#if internal_columns}",
    ctx
  });
  return block;
}
function create_if_block_143(ctx) {
  let if_block_anchor;
  let if_block = (!/*internal_columns*/
  ctx[24][
    /*item*/
    ctx[87]
  ].hidden || !/*internal_columns*/
  ctx[24][
    /*item*/
    ctx[87]
  ].hidden == null) && create_if_block_152(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (!/*internal_columns*/
      ctx2[24][
        /*item*/
        ctx2[87]
      ].hidden || !/*internal_columns*/
      ctx2[24][
        /*item*/
        ctx2[87]
      ].hidden == null) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_152(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_143.name,
    type: "if",
    source: "(756:7) {#if internal_columns[item]}",
    ctx
  });
  return block;
}
function create_if_block_152(ctx) {
  let th;
  let t0_value = (
    /*internal_columns*/
    ctx[24][
      /*item*/
      ctx[87]
    ].label + ""
  );
  let t0;
  let t1;
  let t2;
  let th_data_column_value;
  let mounted;
  let dispose;
  let if_block = (
    /*ColumnSort*/
    ctx[15] == /*item*/
    ctx[87] && create_if_block_162(ctx)
  );
  const block = {
    c: function create() {
      th = element("th");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true, "data-column": true });
      var th_nodes = children(th);
      t0 = claim_text(th_nodes, t0_value);
      t1 = claim_space(th_nodes);
      if (if_block)
        if_block.l(th_nodes);
      t2 = claim_space(th_nodes);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th, "class", "has-text-centered show_cursor_mouse svelte-mg5ytk");
      attr_dev(th, "data-column", th_data_column_value = /*item*/
      ctx[87]);
      add_location(th, file9, 758, 9, 18923);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, t0);
      append_hydration_dev(th, t1);
      if (if_block)
        if_block.m(th, null);
      append_hydration_dev(th, t2);
      if (!mounted) {
        dispose = listen_dev(
          th,
          "click",
          /*HClickHeader*/
          ctx[30],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*internal_columns*/
      16777216 && t0_value !== (t0_value = /*internal_columns*/
      ctx2[24][
        /*item*/
        ctx2[87]
      ].label + ""))
        set_data_dev(t0, t0_value);
      if (
        /*ColumnSort*/
        ctx2[15] == /*item*/
        ctx2[87]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_162(ctx2);
          if_block.c();
          if_block.m(th, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*internal_columns*/
      16777216 && th_data_column_value !== (th_data_column_value = /*item*/
      ctx2[87])) {
        attr_dev(th, "data-column", th_data_column_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_152.name,
    type: "if",
    source: "(757:8) {#if !internal_columns[item].hidden || !internal_columns[item].hidden == null}",
    ctx
  });
  return block;
}
function create_if_block_162(ctx) {
  let if_block_anchor;
  function select_block_type_3(ctx2, dirty) {
    if (
      /*orderASC*/
      ctx2[23]
    )
      return create_if_block_172;
    return create_else_block_15;
  }
  let current_block_type = select_block_type_3(ctx, [-1, -1, -1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type_3(ctx2, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_162.name,
    type: "if",
    source: "(765:10) {#if ColumnSort == item}",
    ctx
  });
  return block;
}
function create_else_block_15(ctx) {
  let i;
  const block = {
    c: function create() {
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", "fas fa-caret-up");
      add_location(i, file9, 768, 12, 19232);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(i);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_15.name,
    type: "else",
    source: "(768:11) {:else}",
    ctx
  });
  return block;
}
function create_if_block_172(ctx) {
  let i;
  const block = {
    c: function create() {
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", "fas fa-caret-down");
      add_location(i, file9, 766, 12, 19169);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(i);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_172.name,
    type: "if",
    source: "(766:11) {#if orderASC}",
    ctx
  });
  return block;
}
function create_each_block_4(ctx) {
  let if_block_anchor;
  let if_block = (
    /*internal_columns*/
    ctx[24][
      /*item*/
      ctx[87]
    ] && create_if_block_143(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*internal_columns*/
        ctx2[24][
          /*item*/
          ctx2[87]
        ]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_143(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_4.name,
    type: "each",
    source: "(754:6) {#each Object.keys(internal_columns) as item, ith}",
    ctx
  });
  return block;
}
function create_if_block_62(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_2 = ensure_array_like_dev(
    /*DataTable*/
    ctx[11].filter(func)
  );
  const get_key = (ctx2) => (
    /*dataRow*/
    ctx2[90].internal_hash_row
  );
  validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);
  for (let i = 0; i < each_value_2.length; i += 1) {
    let child_ctx = get_each_context_2(ctx, each_value_2, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*rowClassFunction, DataTable, internal_columns, HClickCell, HClickEditRow, showEdit, RowIsSelected, SelectionType, PageSize, PageSizeSelected, PageSelected*/
      453529091 | dirty[1] & /*HandleOnRowSelected*/
      64) {
        each_value_2 = ensure_array_like_dev(
          /*DataTable*/
          ctx2[11].filter(func)
        );
        group_outros();
        validate_each_keys(ctx2, each_value_2, get_each_context_2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_2, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_2, each_1_anchor, get_each_context_2);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_62.name,
    type: "if",
    source: "(780:4) {#if DataTable && DataTable.length > 0}",
    ctx
  });
  return block;
}
function create_if_block_123(ctx) {
  let td;
  let input;
  let input_checked_value;
  let input_data_internal_hash_row_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      td = element("td");
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      input = claim_element(td_nodes, "INPUT", {
        class: true,
        type: true,
        "data-internal_hash_row": true
      });
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", "show_cursor_mouse svelte-mg5ytk");
      attr_dev(input, "type", "checkbox");
      input.checked = input_checked_value = /*RowIsSelected*/
      ctx[25](
        /*dataRow*/
        ctx[90].internal_hash_row
      );
      attr_dev(input, "data-internal_hash_row", input_data_internal_hash_row_value = /*dataRow*/
      ctx[90].internal_hash_row);
      add_location(input, file9, 800, 9, 20247);
      attr_dev(td, "class", "has-text-centered");
      add_location(td, file9, 799, 8, 20207);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, input);
      if (!mounted) {
        dispose = listen_dev(
          input,
          "click",
          /*HandleOnRowSelected*/
          ctx[37],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*DataTable*/
      2048 && input_checked_value !== (input_checked_value = /*RowIsSelected*/
      ctx2[25](
        /*dataRow*/
        ctx2[90].internal_hash_row
      ))) {
        prop_dev(input, "checked", input_checked_value);
      }
      if (dirty[0] & /*DataTable*/
      2048 && input_data_internal_hash_row_value !== (input_data_internal_hash_row_value = /*dataRow*/
      ctx2[90].internal_hash_row)) {
        attr_dev(input, "data-internal_hash_row", input_data_internal_hash_row_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_123.name,
    type: "if",
    source: "(799:36) ",
    ctx
  });
  return block;
}
function create_if_block_112(ctx) {
  let td;
  let input;
  let input_checked_value;
  let input_data_internal_hash_row_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      td = element("td");
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      input = claim_element(td_nodes, "INPUT", {
        type: true,
        name: true,
        class: true,
        "data-internal_hash_row": true
      });
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "radio");
      attr_dev(input, "name", "single_select");
      attr_dev(input, "class", "show_cursor_mouse svelte-mg5ytk");
      input.checked = input_checked_value = /*RowIsSelected*/
      ctx[25](
        /*dataRow*/
        ctx[90].internal_hash_row
      );
      attr_dev(input, "data-internal_hash_row", input_data_internal_hash_row_value = /*dataRow*/
      ctx[90].internal_hash_row);
      add_location(input, file9, 789, 10, 19876);
      attr_dev(td, "class", "has-text-centered");
      add_location(td, file9, 788, 8, 19836);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, input);
      if (!mounted) {
        dispose = listen_dev(
          input,
          "click",
          /*HandleOnRowSelected*/
          ctx[37],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*DataTable*/
      2048 && input_checked_value !== (input_checked_value = /*RowIsSelected*/
      ctx2[25](
        /*dataRow*/
        ctx2[90].internal_hash_row
      ))) {
        prop_dev(input, "checked", input_checked_value);
      }
      if (dirty[0] & /*DataTable*/
      2048 && input_data_internal_hash_row_value !== (input_data_internal_hash_row_value = /*dataRow*/
      ctx2[90].internal_hash_row)) {
        attr_dev(input, "data-internal_hash_row", input_data_internal_hash_row_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_112.name,
    type: "if",
    source: "(788:7) {#if SelectionType == 1}",
    ctx
  });
  return block;
}
function create_if_block_102(ctx) {
  let td;
  let span;
  let i;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      td = element("td");
      span = element("span");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      span = claim_element(td_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      i = claim_element(span_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", "fas fa-pen");
      add_location(i, file9, 814, 10, 20745);
      attr_dev(span, "class", "icon is-small");
      add_location(span, file9, 813, 9, 20706);
      attr_dev(td, "class", "has-text-centered show_cursor_mouse svelte-mg5ytk");
      add_location(td, file9, 812, 8, 20614);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, span);
      append_hydration_dev(span, i);
      if (!mounted) {
        dispose = listen_dev(
          td,
          "click",
          function() {
            if (is_function(
              /*HClickEditRow*/
              ctx[28](
                /*dataRow*/
                ctx[90]
              )
            ))
              ctx[28](
                /*dataRow*/
                ctx[90]
              ).apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_102.name,
    type: "if",
    source: "(811:7) {#if showEdit}",
    ctx
  });
  return block;
}
function create_if_block_72(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (!/*internal_columns*/
  ctx[24][
    /*item*/
    ctx[87]
  ].hidden || /*internal_columns*/
  ctx[24][
    /*item*/
    ctx[87]
  ].hidden == null) && create_if_block_82(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*internal_columns*/
      ctx2[24][
        /*item*/
        ctx2[87]
      ].hidden || /*internal_columns*/
      ctx2[24][
        /*item*/
        ctx2[87]
      ].hidden == null) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*internal_columns, DataTable*/
          16779264) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_82(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_72.name,
    type: "if",
    source: "(822:8) {#if internal_columns[item]}",
    ctx
  });
  return block;
}
function create_if_block_82(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_92, create_else_block6];
  const if_blocks = [];
  function select_block_type_5(ctx2, dirty) {
    if (
      /*internal_columns*/
      ctx2[24][
        /*item*/
        ctx2[87]
      ].decorator && /*internal_columns*/
      ctx2[24][
        /*item*/
        ctx2[87]
      ].decorator.component
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_5(ctx, [-1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_5(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_82.name,
    type: "if",
    source: "(823:9) {#if !internal_columns[item].hidden || internal_columns[item].hidden == null}",
    ctx
  });
  return block;
}
function create_else_block6(ctx) {
  let switch_instance;
  let updating_row;
  let updating_value;
  let switch_instance_anchor;
  let current;
  function switch_instance_row_binding_1(value) {
    ctx[54](
      value,
      /*dataRow*/
      ctx[90],
      /*each_value_2*/
      ctx[91],
      /*i*/
      ctx[92]
    );
  }
  function switch_instance_value_binding_1(value) {
    ctx[55](
      value,
      /*dataRow*/
      ctx[90],
      /*item*/
      ctx[87]
    );
  }
  function click_handler_1(...args) {
    return (
      /*click_handler_1*/
      ctx[56](
        /*item*/
        ctx[87],
        /*dataRow*/
        ctx[90],
        ...args
      )
    );
  }
  var switch_value = Auto_default;
  function switch_props(ctx2, dirty) {
    let switch_instance_props = { props: false };
    if (
      /*dataRow*/
      ctx2[90] !== void 0
    ) {
      switch_instance_props.row = /*dataRow*/
      ctx2[90];
    }
    if (
      /*dataRow*/
      ctx2[90][
        /*item*/
        ctx2[87]
      ] !== void 0
    ) {
      switch_instance_props.value = /*dataRow*/
      ctx2[90][
        /*item*/
        ctx2[87]
      ];
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    binding_callbacks.push(() => bind(switch_instance, "row", switch_instance_row_binding_1));
    binding_callbacks.push(() => bind(switch_instance, "value", switch_instance_value_binding_1));
    switch_instance.$on("click", click_handler_1);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (switch_value !== (switch_value = Auto_default)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx, dirty));
          binding_callbacks.push(() => bind(switch_instance, "row", switch_instance_row_binding_1));
          binding_callbacks.push(() => bind(switch_instance, "value", switch_instance_value_binding_1));
          switch_instance.$on("click", click_handler_1);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (!updating_row && dirty[0] & /*DataTable*/
        2048) {
          updating_row = true;
          switch_instance_changes.row = /*dataRow*/
          ctx[90];
          add_flush_callback(() => updating_row = false);
        }
        if (!updating_value && dirty[0] & /*DataTable*/
        2048) {
          updating_value = true;
          switch_instance_changes.value = /*dataRow*/
          ctx[90][
            /*item*/
            ctx[87]
          ];
          add_flush_callback(() => updating_value = false);
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(836:10) {:else}",
    ctx
  });
  return block;
}
function create_if_block_92(ctx) {
  let switch_instance;
  let updating_row;
  let updating_value;
  let switch_instance_anchor;
  let current;
  function switch_instance_row_binding(value) {
    ctx[51](
      value,
      /*dataRow*/
      ctx[90],
      /*each_value_2*/
      ctx[91],
      /*i*/
      ctx[92]
    );
  }
  function switch_instance_value_binding(value) {
    ctx[52](
      value,
      /*dataRow*/
      ctx[90],
      /*item*/
      ctx[87]
    );
  }
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[53](
        /*item*/
        ctx[87],
        /*dataRow*/
        ctx[90],
        ...args
      )
    );
  }
  var switch_value = (
    /*internal_columns*/
    ctx[24][
      /*item*/
      ctx[87]
    ].decorator.component
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      props: (
        /*internal_columns*/
        ctx2[24][
          /*item*/
          ctx2[87]
        ].decorator.props
      )
    };
    if (
      /*dataRow*/
      ctx2[90] !== void 0
    ) {
      switch_instance_props.row = /*dataRow*/
      ctx2[90];
    }
    if (
      /*dataRow*/
      ctx2[90][
        /*item*/
        ctx2[87]
      ] !== void 0
    ) {
      switch_instance_props.value = /*dataRow*/
      ctx2[90][
        /*item*/
        ctx2[87]
      ];
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    binding_callbacks.push(() => bind(switch_instance, "row", switch_instance_row_binding));
    binding_callbacks.push(() => bind(switch_instance, "value", switch_instance_value_binding));
    switch_instance.$on("click", click_handler);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*internal_columns, DataTable*/
      16779264 && switch_value !== (switch_value = /*internal_columns*/
      ctx[24][
        /*item*/
        ctx[87]
      ].decorator.component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx, dirty));
          binding_callbacks.push(() => bind(switch_instance, "row", switch_instance_row_binding));
          binding_callbacks.push(() => bind(switch_instance, "value", switch_instance_value_binding));
          switch_instance.$on("click", click_handler);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*internal_columns, DataTable*/
        16779264)
          switch_instance_changes.props = /*internal_columns*/
          ctx[24][
            /*item*/
            ctx[87]
          ].decorator.props;
        if (!updating_row && dirty[0] & /*DataTable*/
        2048) {
          updating_row = true;
          switch_instance_changes.row = /*dataRow*/
          ctx[90];
          add_flush_callback(() => updating_row = false);
        }
        if (!updating_value && dirty[0] & /*DataTable*/
        2048) {
          updating_value = true;
          switch_instance_changes.value = /*dataRow*/
          ctx[90][
            /*item*/
            ctx[87]
          ];
          add_flush_callback(() => updating_value = false);
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_92.name,
    type: "if",
    source: "(824:10) {#if internal_columns[item].decorator && internal_columns[item].decorator.component}",
    ctx
  });
  return block;
}
function create_each_block_3(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*internal_columns*/
    ctx[24][
      /*item*/
      ctx[87]
    ] && create_if_block_72(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*internal_columns*/
        ctx2[24][
          /*item*/
          ctx2[87]
        ]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*internal_columns, DataTable*/
          16779264) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_72(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(820:7) {#each Object.keys(dataRow) as item, itd}",
    ctx
  });
  return block;
}
function create_each_block_2(key_1, ctx) {
  let tr;
  let td;
  let t0_value = (
    /*i*/
    ctx[92] + 1 + /*PageSize*/
    ctx[10][
      /*PageSizeSelected*/
      ctx[1]
    ] * /*PageSelected*/
    (ctx[19] - 1) + ""
  );
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let tr_class_value;
  let current;
  function select_block_type_4(ctx2, dirty) {
    if (
      /*SelectionType*/
      ctx2[0] == 1
    )
      return create_if_block_112;
    if (
      /*SelectionType*/
      ctx2[0] == 2
    )
      return create_if_block_123;
  }
  let current_block_type = select_block_type_4(ctx, [-1, -1, -1, -1]);
  let if_block0 = current_block_type && current_block_type(ctx);
  let if_block1 = (
    /*showEdit*/
    ctx[14] && create_if_block_102(ctx)
  );
  let each_value_3 = ensure_array_like_dev(Object.keys(
    /*dataRow*/
    ctx[90]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      tr = element("tr");
      td = element("td");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      td = claim_element(tr_nodes, "TD", {});
      var td_nodes = children(td);
      t0 = claim_text(td_nodes, t0_value);
      td_nodes.forEach(detach_dev);
      t1 = claim_space(tr_nodes);
      if (if_block0)
        if_block0.l(tr_nodes);
      t2 = claim_space(tr_nodes);
      if (if_block1)
        if_block1.l(tr_nodes);
      t3 = claim_space(tr_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t4 = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(td, file9, 785, 7, 19728);
      attr_dev(tr, "class", tr_class_value = null_to_empty(
        /*rowClassFunction*/
        ctx[9](
          /*dataRow*/
          ctx[90]
        )
      ) + " svelte-mg5ytk");
      add_location(tr, file9, 784, 6, 19682);
      this.first = tr;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      append_hydration_dev(tr, td);
      append_hydration_dev(td, t0);
      append_hydration_dev(tr, t1);
      if (if_block0)
        if_block0.m(tr, null);
      append_hydration_dev(tr, t2);
      if (if_block1)
        if_block1.m(tr, null);
      append_hydration_dev(tr, t3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      append_hydration_dev(tr, t4);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & /*DataTable, PageSize, PageSizeSelected, PageSelected*/
      527362) && t0_value !== (t0_value = /*i*/
      ctx[92] + 1 + /*PageSize*/
      ctx[10][
        /*PageSizeSelected*/
        ctx[1]
      ] * /*PageSelected*/
      (ctx[19] - 1) + ""))
        set_data_dev(t0, t0_value);
      if (current_block_type === (current_block_type = select_block_type_4(ctx, dirty)) && if_block0) {
        if_block0.p(ctx, dirty);
      } else {
        if (if_block0)
          if_block0.d(1);
        if_block0 = current_block_type && current_block_type(ctx);
        if (if_block0) {
          if_block0.c();
          if_block0.m(tr, t2);
        }
      }
      if (
        /*showEdit*/
        ctx[14]
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_102(ctx);
          if_block1.c();
          if_block1.m(tr, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & /*internal_columns, DataTable, HClickCell*/
      150996992) {
        each_value_3 = ensure_array_like_dev(Object.keys(
          /*dataRow*/
          ctx[90]
        ));
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx, each_value_3, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(tr, t4);
          }
        }
        group_outros();
        for (i = each_value_3.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty[0] & /*rowClassFunction, DataTable*/
      2560 && tr_class_value !== (tr_class_value = null_to_empty(
        /*rowClassFunction*/
        ctx[9](
          /*dataRow*/
          ctx[90]
        )
      ) + " svelte-mg5ytk")) {
        attr_dev(tr, "class", tr_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tr);
      }
      if (if_block0) {
        if_block0.d();
      }
      if (if_block1)
        if_block1.d();
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(781:5) {#each DataTable.filter((ev) => {       // Se puso este filtro para evitar errores cuando hay registros nulos o no tengan internal_hash_row       return ev && ev.internal_hash_row;      }) as dataRow, i (dataRow.internal_hash_row)}",
    ctx
  });
  return block;
}
function create_if_block_111(ctx) {
  let div0;
  let span0;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let div2;
  let div1;
  let button0;
  let span1;
  let i0;
  let t8;
  let button1;
  let span2;
  let i1;
  let t9;
  let button2;
  let t10;
  let t11;
  let t12;
  let t13;
  let t14;
  let t15;
  let button3;
  let span3;
  let i2;
  let t16;
  let button4;
  let span4;
  let i3;
  let mounted;
  let dispose;
  let if_block0 = (
    /*PageSelected*/
    ctx[19] + 1 <= /*TotalPages*/
    ctx[21] && create_if_block_52(ctx)
  );
  let if_block1 = (
    /*PageSelected*/
    ctx[19] + 2 <= /*TotalPages*/
    ctx[21] && create_if_block_42(ctx)
  );
  let if_block2 = (
    /*PageSelected*/
    ctx[19] + 3 <= /*TotalPages*/
    ctx[21] && create_if_block_310(ctx)
  );
  let if_block3 = (
    /*PageSelected*/
    ctx[19] + 4 <= /*TotalPages*/
    ctx[21] && create_if_block_210(ctx)
  );
  const block = {
    c: function create() {
      div0 = element("div");
      span0 = element("span");
      t0 = text("Página ");
      t1 = text(
        /*PageSelected*/
        ctx[19]
      );
      t2 = text(" de ");
      t3 = text(
        /*TotalPages*/
        ctx[21]
      );
      t4 = text(" (Total ");
      t5 = text(
        /*totalFilteredRows*/
        ctx[20]
      );
      t6 = text("\n							filas)");
      t7 = space();
      div2 = element("div");
      div1 = element("div");
      button0 = element("button");
      span1 = element("span");
      i0 = element("i");
      t8 = space();
      button1 = element("button");
      span2 = element("span");
      i1 = element("i");
      t9 = space();
      button2 = element("button");
      t10 = text(
        /*PageSelected*/
        ctx[19]
      );
      t11 = space();
      if (if_block0)
        if_block0.c();
      t12 = space();
      if (if_block1)
        if_block1.c();
      t13 = space();
      if (if_block2)
        if_block2.c();
      t14 = space();
      if (if_block3)
        if_block3.c();
      t15 = space();
      button3 = element("button");
      span3 = element("span");
      i2 = element("i");
      t16 = space();
      button4 = element("button");
      span4 = element("span");
      i3 = element("i");
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      span0 = claim_element(div0_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, "Página ");
      t1 = claim_text(
        span0_nodes,
        /*PageSelected*/
        ctx[19]
      );
      t2 = claim_text(span0_nodes, " de ");
      t3 = claim_text(
        span0_nodes,
        /*TotalPages*/
        ctx[21]
      );
      t4 = claim_text(span0_nodes, " (Total ");
      t5 = claim_text(
        span0_nodes,
        /*totalFilteredRows*/
        ctx[20]
      );
      t6 = claim_text(span0_nodes, "\n							filas)");
      span0_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t7 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      button0 = claim_element(div1_nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      span1 = claim_element(button0_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      i0 = claim_element(span1_nodes, "I", { class: true });
      children(i0).forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      button0_nodes.forEach(detach_dev);
      t8 = claim_space(div1_nodes);
      button1 = claim_element(div1_nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      span2 = claim_element(button1_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      i1 = claim_element(span2_nodes, "I", { class: true });
      children(i1).forEach(detach_dev);
      span2_nodes.forEach(detach_dev);
      button1_nodes.forEach(detach_dev);
      t9 = claim_space(div1_nodes);
      button2 = claim_element(div1_nodes, "BUTTON", { class: true });
      var button2_nodes = children(button2);
      t10 = claim_text(
        button2_nodes,
        /*PageSelected*/
        ctx[19]
      );
      button2_nodes.forEach(detach_dev);
      t11 = claim_space(div1_nodes);
      if (if_block0)
        if_block0.l(div1_nodes);
      t12 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      t13 = claim_space(div1_nodes);
      if (if_block2)
        if_block2.l(div1_nodes);
      t14 = claim_space(div1_nodes);
      if (if_block3)
        if_block3.l(div1_nodes);
      t15 = claim_space(div1_nodes);
      button3 = claim_element(div1_nodes, "BUTTON", { class: true });
      var button3_nodes = children(button3);
      span3 = claim_element(button3_nodes, "SPAN", { class: true });
      var span3_nodes = children(span3);
      i2 = claim_element(span3_nodes, "I", { class: true });
      children(i2).forEach(detach_dev);
      span3_nodes.forEach(detach_dev);
      button3_nodes.forEach(detach_dev);
      t16 = claim_space(div1_nodes);
      button4 = claim_element(div1_nodes, "BUTTON", { class: true });
      var button4_nodes = children(button4);
      span4 = claim_element(button4_nodes, "SPAN", { class: true });
      var span4_nodes = children(span4);
      i3 = claim_element(span4_nodes, "I", { class: true });
      children(i3).forEach(detach_dev);
      span4_nodes.forEach(detach_dev);
      button4_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "");
      add_location(span0, file9, 864, 6, 22257);
      attr_dev(div0, "class", "level-item");
      add_location(div0, file9, 863, 5, 22226);
      attr_dev(i0, "class", "fas fa-angle-double-left");
      add_location(i0, file9, 879, 9, 22634);
      attr_dev(span1, "class", "icon");
      add_location(span1, file9, 878, 8, 22605);
      attr_dev(button0, "class", "button is-small");
      add_location(button0, file9, 871, 7, 22461);
      attr_dev(i1, "class", "fas fa-angle-left");
      add_location(i1, file9, 892, 9, 22946);
      attr_dev(span2, "class", "icon");
      add_location(span2, file9, 891, 8, 22917);
      attr_dev(button1, "class", "button is-small");
      add_location(button1, file9, 882, 7, 22713);
      attr_dev(button2, "class", "button is-small is-info");
      add_location(button2, file9, 895, 7, 23018);
      attr_dev(i2, "class", "fas fa-angle-right");
      add_location(i2, file9, 951, 9, 24436);
      attr_dev(span3, "class", "icon");
      add_location(span3, file9, 950, 8, 24407);
      attr_dev(button3, "class", "button is-small");
      add_location(button3, file9, 941, 7, 24193);
      attr_dev(i3, "class", "fas fa-angle-double-right");
      add_location(i3, file9, 963, 9, 24692);
      attr_dev(span4, "class", "icon");
      add_location(span4, file9, 962, 8, 24663);
      attr_dev(button4, "class", "button is-small");
      add_location(button4, file9, 955, 7, 24510);
      attr_dev(div1, "class", "buttons has-addons");
      add_location(div1, file9, 870, 6, 22421);
      attr_dev(div2, "class", "level-item");
      add_location(div2, file9, 869, 5, 22390);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      append_hydration_dev(div0, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(span0, t1);
      append_hydration_dev(span0, t2);
      append_hydration_dev(span0, t3);
      append_hydration_dev(span0, t4);
      append_hydration_dev(span0, t5);
      append_hydration_dev(span0, t6);
      insert_hydration_dev(target, t7, anchor);
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, button0);
      append_hydration_dev(button0, span1);
      append_hydration_dev(span1, i0);
      append_hydration_dev(div1, t8);
      append_hydration_dev(div1, button1);
      append_hydration_dev(button1, span2);
      append_hydration_dev(span2, i1);
      append_hydration_dev(div1, t9);
      append_hydration_dev(div1, button2);
      append_hydration_dev(button2, t10);
      append_hydration_dev(div1, t11);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t12);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration_dev(div1, t13);
      if (if_block2)
        if_block2.m(div1, null);
      append_hydration_dev(div1, t14);
      if (if_block3)
        if_block3.m(div1, null);
      append_hydration_dev(div1, t15);
      append_hydration_dev(div1, button3);
      append_hydration_dev(button3, span3);
      append_hydration_dev(span3, i2);
      append_hydration_dev(div1, t16);
      append_hydration_dev(div1, button4);
      append_hydration_dev(button4, span4);
      append_hydration_dev(span4, i3);
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*click_handler_2*/
            ctx[57],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*click_handler_3*/
            ctx[58],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button2,
            "click",
            /*click_handler_4*/
            ctx[59],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button3,
            "click",
            /*click_handler_9*/
            ctx[64],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button4,
            "click",
            /*click_handler_10*/
            ctx[65],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*PageSelected*/
      524288)
        set_data_dev(
          t1,
          /*PageSelected*/
          ctx2[19]
        );
      if (dirty[0] & /*TotalPages*/
      2097152)
        set_data_dev(
          t3,
          /*TotalPages*/
          ctx2[21]
        );
      if (dirty[0] & /*totalFilteredRows*/
      1048576)
        set_data_dev(
          t5,
          /*totalFilteredRows*/
          ctx2[20]
        );
      if (dirty[0] & /*PageSelected*/
      524288)
        set_data_dev(
          t10,
          /*PageSelected*/
          ctx2[19]
        );
      if (
        /*PageSelected*/
        ctx2[19] + 1 <= /*TotalPages*/
        ctx2[21]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_52(ctx2);
          if_block0.c();
          if_block0.m(div1, t12);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*PageSelected*/
        ctx2[19] + 2 <= /*TotalPages*/
        ctx2[21]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_42(ctx2);
          if_block1.c();
          if_block1.m(div1, t13);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*PageSelected*/
        ctx2[19] + 3 <= /*TotalPages*/
        ctx2[21]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_310(ctx2);
          if_block2.c();
          if_block2.m(div1, t14);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*PageSelected*/
        ctx2[19] + 4 <= /*TotalPages*/
        ctx2[21]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_210(ctx2);
          if_block3.c();
          if_block3.m(div1, t15);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div0);
        detach_dev(t7);
        detach_dev(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_111.name,
    type: "if",
    source: "(863:4) {#if paginatedData && paginatedData.length > 1}",
    ctx
  });
  return block;
}
function create_if_block_52(ctx) {
  let button;
  let t_value = (
    /*PageSelected*/
    ctx[19] + 1 + ""
  );
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "button is-small");
      add_location(button, file9, 903, 8, 23239);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_5*/
          ctx[60],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*PageSelected*/
      524288 && t_value !== (t_value = /*PageSelected*/
      ctx2[19] + 1 + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: "(903:7) {#if PageSelected + 1 <= TotalPages}",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let button;
  let t_value = (
    /*PageSelected*/
    ctx[19] + 2 + ""
  );
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "button is-small");
      add_location(button, file9, 912, 8, 23488);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_6*/
          ctx[61],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*PageSelected*/
      524288 && t_value !== (t_value = /*PageSelected*/
      ctx2[19] + 2 + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(912:7) {#if PageSelected + 2 <= TotalPages}",
    ctx
  });
  return block;
}
function create_if_block_310(ctx) {
  let button;
  let t_value = (
    /*PageSelected*/
    ctx[19] + 3 + ""
  );
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "button is-small");
      add_location(button, file9, 922, 8, 23738);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_7*/
          ctx[62],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*PageSelected*/
      524288 && t_value !== (t_value = /*PageSelected*/
      ctx2[19] + 3 + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_310.name,
    type: "if",
    source: "(922:7) {#if PageSelected + 3 <= TotalPages}",
    ctx
  });
  return block;
}
function create_if_block_210(ctx) {
  let button;
  let t_value = (
    /*PageSelected*/
    ctx[19] + 4 + ""
  );
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "button is-small");
      add_location(button, file9, 932, 8, 23988);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_8*/
          ctx[63],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*PageSelected*/
      524288 && t_value !== (t_value = /*PageSelected*/
      ctx2[19] + 4 + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_210.name,
    type: "if",
    source: "(932:7) {#if PageSelected + 4 <= TotalPages}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let option;
  let t_value = (
    /*item*/
    ctx[87] + ""
  );
  let t;
  let option_value_value;
  let option_selected_value;
  const block = {
    c: function create() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*itd*/
      ctx[89];
      set_input_value(option, option.__value);
      option.selected = option_selected_value = /*item*/
      ctx[87] == /*PageSize*/
      ctx[10][
        /*PageSizeSelected*/
        ctx[1]
      ];
      add_location(option, file9, 986, 8, 25273);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*PageSize*/
      1024 && t_value !== (t_value = /*item*/
      ctx2[87] + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*PageSize, PageSizeSelected*/
      1026 && option_selected_value !== (option_selected_value = /*item*/
      ctx2[87] == /*PageSize*/
      ctx2[10][
        /*PageSizeSelected*/
        ctx2[1]
      ])) {
        prop_dev(option, "selected", option_selected_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(986:7) {#each PageSize as item, itd}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let div;
  let label;
  let input;
  let t0;
  let t1_value = (
    /*col*/
    ctx[84] + ""
  );
  let t1;
  let t2;
  const block = {
    c: function create() {
      div = element("div");
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      label = claim_element(div_nodes, "LABEL", { class: true });
      var label_nodes = children(label);
      input = claim_element(label_nodes, "INPUT", { type: true });
      t0 = claim_space(label_nodes);
      t1 = claim_text(label_nodes, t1_value);
      label_nodes.forEach(detach_dev);
      t2 = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      add_location(input, file9, 1023, 7, 26152);
      attr_dev(label, "class", "checkbox");
      add_location(label, file9, 1022, 6, 26120);
      attr_dev(div, "class", "column");
      add_location(div, file9, 1021, 5, 26093);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, label);
      append_hydration_dev(label, input);
      append_hydration_dev(label, t0);
      append_hydration_dev(label, t1);
      append_hydration_dev(div, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*columns*/
      4 && t1_value !== (t1_value = /*col*/
      ctx2[84] + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(1021:4) {#each Object.keys(columns) as col}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let level;
  let t0;
  let current_block_type_index;
  let if_block;
  let t1;
  let div3;
  let div0;
  let t2;
  let div2;
  let header;
  let p;
  let b;
  let span0;
  let textContent = "Columnas";
  let t4;
  let button0;
  let t5;
  let section;
  let div1;
  let t6;
  let footer;
  let button1;
  let span1;
  let textContent_1 = "Aceptar";
  let t8;
  let button2;
  let span2;
  let textContent_2 = "Cancelar";
  let current;
  let mounted;
  let dispose;
  level = new Level_default({
    props: {
      $$slots: {
        r10: [create_r10_slot],
        r09: [create_r09_slot],
        r08: [create_r08_slot],
        r07: [create_r07_slot],
        r06: [create_r06_slot],
        r05: [create_r05_slot],
        r04: [create_r04_slot],
        r03: [create_r03_slot],
        r02: [create_r02_slot],
        r01: [create_r01_slot],
        l10: [create_l10_slot],
        l09: [create_l09_slot],
        l08: [create_l08_slot],
        l07: [create_l07_slot],
        l06: [create_l06_slot],
        l05: [create_l05_slot],
        l04: [create_l04_slot],
        l03: [create_l03_slot],
        l02: [create_l02_slot],
        l01: [create_l01_slot]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const if_block_creators = [create_if_block7, create_else_block_2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*DataTable*/
      ctx2[11] && /*DataTable*/
      ctx2[11].length > 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let each_value = ensure_array_like_dev(Object.keys(
    /*columns*/
    ctx[2]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      create_component(level.$$.fragment);
      t0 = space();
      if_block.c();
      t1 = space();
      div3 = element("div");
      div0 = element("div");
      t2 = space();
      div2 = element("div");
      header = element("header");
      p = element("p");
      b = element("b");
      span0 = element("span");
      span0.textContent = textContent;
      t4 = space();
      button0 = element("button");
      t5 = space();
      section = element("section");
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t6 = space();
      footer = element("footer");
      button1 = element("button");
      span1 = element("span");
      span1.textContent = textContent_1;
      t8 = space();
      button2 = element("button");
      span2 = element("span");
      span2.textContent = textContent_2;
      this.h();
    },
    l: function claim(nodes) {
      claim_component(level.$$.fragment, nodes);
      t0 = claim_space(nodes);
      if_block.l(nodes);
      t1 = claim_space(nodes);
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t2 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      header = claim_element(div2_nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      p = claim_element(header_nodes, "P", { class: true });
      var p_nodes = children(p);
      b = claim_element(p_nodes, "B", {});
      var b_nodes = children(b);
      span0 = claim_element(b_nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span0) !== "svelte-vh4yv0")
        span0.textContent = textContent;
      b_nodes.forEach(detach_dev);
      p_nodes.forEach(detach_dev);
      t4 = claim_space(header_nodes);
      button0 = claim_element(header_nodes, "BUTTON", { class: true, "aria-label": true });
      children(button0).forEach(detach_dev);
      header_nodes.forEach(detach_dev);
      t5 = claim_space(div2_nodes);
      section = claim_element(div2_nodes, "SECTION", { class: true });
      var section_nodes = children(section);
      div1 = claim_element(section_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div1_nodes);
      }
      div1_nodes.forEach(detach_dev);
      section_nodes.forEach(detach_dev);
      t6 = claim_space(div2_nodes);
      footer = claim_element(div2_nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      button1 = claim_element(footer_nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      span1 = claim_element(button1_nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span1) !== "svelte-dm5e66")
        span1.textContent = textContent_1;
      button1_nodes.forEach(detach_dev);
      t8 = claim_space(footer_nodes);
      button2 = claim_element(footer_nodes, "BUTTON", { class: true });
      var button2_nodes = children(button2);
      span2 = claim_element(button2_nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span2) !== "svelte-hoxmuj")
        span2.textContent = textContent_2;
      button2_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "modal-background");
      add_location(div0, file9, 1002, 1, 25642);
      add_location(span0, file9, 1007, 5, 25816);
      add_location(b, file9, 1006, 4, 25807);
      attr_dev(p, "class", "modal-card-title has-text-white");
      add_location(p, file9, 1005, 3, 25759);
      attr_dev(button0, "class", "delete");
      attr_dev(button0, "aria-label", "close");
      add_location(button0, file9, 1010, 3, 25858);
      attr_dev(header, "class", "modal-card-head has-background-dark");
      add_location(header, file9, 1004, 2, 25703);
      attr_dev(div1, "class", "columns");
      add_location(div1, file9, 1019, 3, 26026);
      attr_dev(section, "class", "modal-card-body");
      add_location(section, file9, 1018, 2, 25989);
      add_location(span1, file9, 1033, 4, 26360);
      attr_dev(button1, "class", "button is-success is-small");
      add_location(button1, file9, 1032, 3, 26312);
      add_location(span2, file9, 1041, 4, 26503);
      attr_dev(button2, "class", "button is-small");
      add_location(button2, file9, 1035, 3, 26397);
      attr_dev(footer, "class", "modal-card-foot has-background-dark");
      add_location(footer, file9, 1031, 2, 26256);
      attr_dev(div2, "class", "modal-card");
      add_location(div2, file9, 1003, 1, 25676);
      attr_dev(div3, "class", "modal");
      toggle_class(
        div3,
        "is-active",
        /*ShowDialogColumn*/
        ctx[16]
      );
      add_location(div3, file9, 1001, 0, 25586);
    },
    m: function mount(target, anchor) {
      mount_component(level, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div3, t2);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, header);
      append_hydration_dev(header, p);
      append_hydration_dev(p, b);
      append_hydration_dev(b, span0);
      append_hydration_dev(header, t4);
      append_hydration_dev(header, button0);
      append_hydration_dev(div2, t5);
      append_hydration_dev(div2, section);
      append_hydration_dev(section, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      append_hydration_dev(div2, t6);
      append_hydration_dev(div2, footer);
      append_hydration_dev(footer, button1);
      append_hydration_dev(button1, span1);
      append_hydration_dev(footer, t8);
      append_hydration_dev(footer, button2);
      append_hydration_dev(button2, span2);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*click_handler_11*/
            ctx[67],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button2,
            "click",
            /*click_handler_12*/
            ctx[68],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const level_changes = {};
      if (dirty[0] & /*timeRemainingToRefresh, loading, LastFetchResponse, url, ShowNewButton, ShowEditButton, SelectionType, ShowSelectionButton, iconExport, ShowExportButton, text_search*/
      406009 | dirty[1] & /*$$slots*/
      128 | dirty[2] & /*$$scope*/
      128) {
        level_changes.$$scope = { dirty, ctx: ctx2 };
      }
      level.$set(level_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t1.parentNode, t1);
      }
      if (dirty[0] & /*columns*/
      4) {
        each_value = ensure_array_like_dev(Object.keys(
          /*columns*/
          ctx2[2]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty[0] & /*ShowDialogColumn*/
      65536) {
        toggle_class(
          div3,
          "is-active",
          /*ShowDialogColumn*/
          ctx2[16]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(level.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(level.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(div3);
      }
      destroy_component(level, detaching);
      if_blocks[current_block_type_index].d(detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
async function hash(string) {
  try {
    const utf8 = new TextEncoder().encode(string);
    let hashBuffer = await crypto.subtle.digest("SHA-256", utf8);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map((bytes) => bytes.toString(16).padStart(2, "0")).join("");
    return hashHex;
  } catch (error) {
    console.error(error);
    return "";
  }
}
function ArrayChunk(myArray, chunk_size) {
  let tempArray = [];
  chunk_size = parseInt(chunk_size);
  if (myArray && Array.isArray(myArray)) {
    for (let index = 0; index < myArray.length; index += chunk_size) {
      let myChunk = myArray.slice(index, index + chunk_size);
      tempArray.push(myChunk);
    }
  }
  return tempArray;
}
function SortColumn(key, order = "asc") {
  return function innerSort(a, b) {
    if (!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) {
      return 0;
    }
    const varA = typeof a[key] === "string" ? a[key].toUpperCase() : a[key];
    const varB = typeof b[key] === "string" ? b[key].toUpperCase() : b[key];
    let comparison = 0;
    if (varA > varB) {
      comparison = 1;
    } else if (varA < varB) {
      comparison = -1;
    }
    return order === "desc" ? comparison * -1 : comparison;
  };
}
var func = (ev) => {
  return ev && ev.internal_hash_row;
};
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, [
    "r10",
    "r09",
    "r08",
    "r07",
    "l10",
    "l09",
    "l08",
    "l07",
    "l06",
    "l05",
    "l04",
    "l03",
    "l02",
    "l01"
  ]);
  const $$slots = compute_slots(slots);
  "use strict";
  let { RawDataTable = [] } = $$props;
  let { SelectionType = 0 } = $$props;
  let { columns = {} } = $$props;
  let { url = "" } = $$props;
  let { params = {} } = $$props;
  let { ShowNewButton = false } = $$props;
  let { ShowEditButton = false } = $$props;
  let { ShowSelectionButton = true } = $$props;
  let { ShowExportButton = true } = $$props;
  let { iconExport = "fa-solid fa-file-excel" } = $$props;
  let { rowClassFunction = function(row) {
    return "";
  } } = $$props;
  const FetchData = new import_universal_fetch.default();
  const dispatch = createEventDispatcher();
  let DataTable = [];
  let SelectedRows = [];
  let text_search;
  let loading = false;
  let showEdit = false;
  let ColumnSort;
  let ShowDialogColumn = false;
  let timeRemainingToRefresh = 999;
  let LastFetchResponse = true;
  let IntervalRefresh = [10, 20, 30, 45, 60, 120, 240, 480, 960, 1920, 3840];
  let { IntervalRefreshSelected = 4 } = $$props;
  let { PageSize = [25, 50, 100, 200, 300, 500, 1e3] } = $$props;
  let { PageSizeSelected = 0 } = $$props;
  let { relatedTablesForAutoRefresh = [] } = $$props;
  let { fileNameExport = "" } = $$props;
  let PageSelected = 1;
  let totalFilteredRows = 0;
  let TotalPages = 0;
  let paginatedData = [];
  let SelectAll = false;
  let orderASC = true;
  let internal_columns = {};
  function OnSelection() {
    dispatch("selectrows", { rows: GetSelectedRows() });
  }
  onMount(() => {
    $$invalidate(17, timeRemainingToRefresh = 0);
    storeChangedTables.subscribe((value) => {
      try {
        if (relatedTablesForAutoRefresh.includes(value.table)) {
          auto_refresh_by_table_changed_request++;
        }
      } catch (error) {
        console.log(error);
      }
    });
  });
  function SetColumns() {
    if (RawDataTable && RawDataTable.length > 0) {
      let MaxSizeLabel = 15;
      $$invalidate(24, internal_columns = {});
      Object.keys(RawDataTable[0]).forEach((item) => {
        if (item === "internal_hash_row") {
          $$invalidate(
            24,
            internal_columns[item] = {
              label: item.substring(0, MaxSizeLabel),
              hidden: true
            },
            internal_columns
          );
        } else if (columns[item]) {
          $$invalidate(24, internal_columns[item] = columns[item], internal_columns);
          if (!internal_columns[item].label) {
            $$invalidate(24, internal_columns[item].label = item.substring(0, MaxSizeLabel), internal_columns);
          }
        } else {
          $$invalidate(
            24,
            internal_columns[item] = {
              label: item.substring(0, MaxSizeLabel),
              hidden: false
            },
            internal_columns
          );
        }
      });
    }
  }
  function RowIsSelected(internal_hash_row) {
    let isSelected = SelectedRows.includes(internal_hash_row);
    return isSelected;
  }
  function GetSelectedRows() {
    return RawDataTable.filter((row) => {
      return SelectedRows.includes(row.internal_hash_row);
    });
  }
  function ExportTable() {
    try {
      console.log("ExportTable > Columns ", columns);
      let filteredData = GetSelectedRows();
      let ExceedsCharacterLimitPerCell = false;
      let FormatedData = filteredData.map((row) => {
        let r = { ...row };
        Object.keys(row).forEach((key) => {
          if (columns[key] && columns[key].hidden) {
            delete r[key];
          } else if (columns[key] && columns[key].decorator && columns[key].decorator.component && columns[key].decorator.component === DateTime_default) {
            r[key] = DateTime.fromISO(row[key]).toFormat("yyyy-MM-dd HH:mm:ss");
          } else if (row[key] !== null && typeof row[key] === "object") {
            r[key] = JSON.stringify(row[key]);
            let caracteres = r[key].length;
            if (caracteres >= 32767) {
              ExceedsCharacterLimitPerCell = true;
              console.warn(`El valor de la columna ${key} es muy largo para ser exportado, se ha limitado a 32767 caracteres`);
            }
          }
        });
        delete r.internal_hash_row;
        return r;
      });
      console.log("FormatedData", FormatedData, xlsx_exports);
      if (FormatedData && FormatedData.length > 0) {
        var ws = utils.json_to_sheet(FormatedData);
        var wb = utils.book_new();
        utils.book_append_sheet(wb, ws, "Report");
        let ExtensionFile = "xlsx";
        if (ExceedsCharacterLimitPerCell) {
          ExtensionFile = "csv";
        }
        let fName = "Report";
        if (fName && fName.length > 0) {
          fName = fileNameExport;
        }
        let NameFile = `${fName}_${DateTime.local().toFormat("yyyy-MM-dd_HH-mm-ss")}.${ExtensionFile}`;
        var wopts = {
          bookType: ExtensionFile,
          bookSST: false,
          type: "binary",
          FS: ";"
        };
        writeFileSync(wb, NameFile, wopts);
      } else {
        alert("Por favor seleccione los registros a exportar");
        $$invalidate(0, SelectionType = 2);
      }
    } catch (error) {
      console.error(error);
    }
  }
  let auto_refresh_by_table_changed_request = 0;
  let auto_refresh = setInterval(
    async () => {
      if (timeRemainingToRefresh == 0 || auto_refresh_by_table_changed_request > 0) {
        await GetDataTable();
        $$invalidate(17, timeRemainingToRefresh = IntervalRefresh[IntervalRefreshSelected]);
        auto_refresh_by_table_changed_request = 0;
      } else {
        $$invalidate(17, timeRemainingToRefresh--, timeRemainingToRefresh);
      }
    },
    1e3
  );
  let hash_last_data = "";
  let check_changes_data = setInterval(
    () => {
      try {
        let hash_data = sha256(JSON.stringify(RawDataTable));
        if (hash_last_data !== hash_data) {
          hash_last_data = hash_data;
          ProcessRawData();
        }
      } catch (error) {
        console.error(error);
      }
    },
    500
  );
  onDestroy(() => {
    clearInterval(auto_refresh);
    clearInterval(check_changes_data);
  });
  function ChangeIntervalRefresh() {
    let i = IntervalRefreshSelected + 1;
    if (IntervalRefresh[i]) {
      $$invalidate(40, IntervalRefreshSelected = i);
    } else {
      $$invalidate(40, IntervalRefreshSelected = 0);
    }
    $$invalidate(17, timeRemainingToRefresh = IntervalRefresh[IntervalRefreshSelected]);
  }
  function HClickCell(cell, row) {
    dispatch("clickrow", { field: cell, data: row });
  }
  function HClickEditRow(e) {
    dispatch("editrow", { data: e });
  }
  function HClickNew(e) {
    dispatch("newrow", e);
  }
  function HClickHeader(e) {
    $$invalidate(15, ColumnSort = e.target.dataset.column);
    $$invalidate(23, orderASC = !orderASC);
    FilterData();
  }
  function handleClickSearch() {
    if (text_search && text_search.length > 0) {
      FilterData();
    } else {
      FilterData();
      $$invalidate(17, timeRemainingToRefresh = 0);
    }
  }
  function handleChangeSelectAll(e) {
    SelectAll = e.target.checked;
    if (SelectAll) {
      $$invalidate(45, SelectedRows = []);
      paginatedData.forEach((pag) => {
        $$invalidate(45, SelectedRows = SelectedRows.concat(pag.map((item) => {
          return item.internal_hash_row;
        })));
      });
    } else {
      $$invalidate(45, SelectedRows = []);
    }
    FilterData();
  }
  function handleExportSelection(e) {
    ExportTable();
  }
  function FilterData() {
    let TempData;
    if (text_search && text_search.length > 0) {
      TempData = RawDataTable.filter((d) => {
        let s = Object.values(d).filter((item) => {
          if (item) {
            return item.toString().toUpperCase().includes(text_search.toUpperCase());
          } else {
            return item;
          }
        });
        if (s.length > 0) {
          return true;
        } else {
          return false;
        }
      });
    } else {
      TempData = RawDataTable;
    }
    $$invalidate(20, totalFilteredRows = TempData.length);
    Pagination(TempData);
  }
  function Pagination(rows) {
    if (ColumnSort) {
      if (orderASC) {
        rows = rows.sort(SortColumn(ColumnSort));
      } else {
        rows = rows.sort(SortColumn(ColumnSort, "desc"));
      }
    }
    $$invalidate(22, paginatedData = ArrayChunk(rows, PageSize[PageSizeSelected]));
    $$invalidate(21, TotalPages = paginatedData.length);
    if (PageSelected > TotalPages) {
      $$invalidate(19, PageSelected = 1);
    }
    SelectPage();
  }
  function SelectPage() {
    $$invalidate(11, DataTable = paginatedData[PageSelected - 1]);
  }
  function HandleOnClickEdit() {
    $$invalidate(14, showEdit = !showEdit);
    return false;
  }
  function HandleOnRowSelected(event) {
    if (SelectionType == 1) {
      $$invalidate(45, SelectedRows = []);
    }
    let internal_hash_row = event.target.dataset.internal_hash_row;
    if (event.target.checked) {
      SelectedRows.push(internal_hash_row);
    } else {
      $$invalidate(45, SelectedRows = SelectedRows.filter((value) => {
        return value !== internal_hash_row;
      }));
    }
    OnSelection();
  }
  function ProcessRawData() {
    let Listinternal_hash_row = {};
    let tmp_RawDataTable = [];
    if (Array.isArray(RawDataTable)) {
      for (const row_org of RawDataTable) {
        let row = { ...row_org };
        row.internal_hash_row = 0;
        let c = sha256(JSON.stringify(row));
        console.log("Registro HASH >> ", c);
        if (Listinternal_hash_row[c]) {
          console.error("Hay un registro duplicado en la tabla", row);
          c = c + "-" + (/* @__PURE__ */ new Date()).getTime() + "-" + Math.floor(Math.random() * 1e4);
          Listinternal_hash_row[c] = true;
        } else {
          Listinternal_hash_row[c] = true;
        }
        row.internal_hash_row = c;
        tmp_RawDataTable.push(row);
      }
    } else {
      console.log("RawDataTable no es array", RawDataTable);
      $$invalidate(39, RawDataTable = []);
    }
    $$invalidate(39, RawDataTable = tmp_RawDataTable);
    tmp_RawDataTable = [];
    SetColumns();
    FilterData();
  }
  async function GetDataTable() {
    console.log("GetDataTable");
    if (loading) {
      console.log("Hay una petición en curso");
    } else {
      if (url && url.length > 0) {
        try {
          $$invalidate(13, loading = true);
          let res = await FetchData.get(url, params);
          if (res && res.status == 200) {
            let data = await res.json();
            if (Array.isArray(data)) {
              $$invalidate(39, RawDataTable = data);
              $$invalidate(18, LastFetchResponse = true);
            } else {
              console.warn(data);
              $$invalidate(39, RawDataTable = []);
              $$invalidate(18, LastFetchResponse = false);
            }
          } else {
            console.error(res);
            $$invalidate(18, LastFetchResponse = false);
          }
          $$invalidate(13, loading = false);
        } catch (error) {
          console.error(error);
          $$invalidate(13, loading = false);
          $$invalidate(18, LastFetchResponse = false);
        }
      } else {
        console.warn("Not url asigned");
        $$invalidate(18, LastFetchResponse = false);
      }
    }
  }
  const writable_props = [
    "RawDataTable",
    "SelectionType",
    "columns",
    "url",
    "params",
    "ShowNewButton",
    "ShowEditButton",
    "ShowSelectionButton",
    "ShowExportButton",
    "iconExport",
    "rowClassFunction",
    "IntervalRefreshSelected",
    "PageSize",
    "PageSizeSelected",
    "relatedTablesForAutoRefresh",
    "fileNameExport"
  ];
  Object_12.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<Table> was created with unknown prop '${key}'`);
  });
  const change_handler = () => {
    $$invalidate(0, SelectionType = 1);
  };
  const change_handler_1 = () => {
    $$invalidate(0, SelectionType = 2);
  };
  const change_handler_2 = () => {
    $$invalidate(0, SelectionType = 0);
  };
  function input_input_handler() {
    text_search = this.value;
    $$invalidate(12, text_search);
  }
  function switch_instance_row_binding(value, dataRow, each_value_2, i) {
    each_value_2[i] = value;
    $$invalidate(11, DataTable);
  }
  function switch_instance_value_binding(value, dataRow, item) {
    if ($$self.$$.not_equal(dataRow[item], value)) {
      dataRow[item] = value;
      $$invalidate(11, DataTable);
    }
  }
  const click_handler = (item, dataRow, e) => {
    HClickCell(item, dataRow);
  };
  function switch_instance_row_binding_1(value, dataRow, each_value_2, i) {
    each_value_2[i] = value;
    $$invalidate(11, DataTable);
  }
  function switch_instance_value_binding_1(value, dataRow, item) {
    if ($$self.$$.not_equal(dataRow[item], value)) {
      dataRow[item] = value;
      $$invalidate(11, DataTable);
    }
  }
  const click_handler_1 = (item, dataRow, e) => {
    HClickCell(item, dataRow);
  };
  const click_handler_2 = () => {
    $$invalidate(19, PageSelected = 1);
    SelectPage();
  };
  const click_handler_3 = () => {
    if (PageSelected > 1) {
      $$invalidate(19, PageSelected = PageSelected - 1);
    }
    SelectPage();
  };
  const click_handler_4 = () => {
    SelectPage();
  };
  const click_handler_5 = () => {
    $$invalidate(19, PageSelected = PageSelected + 1);
    SelectPage();
  };
  const click_handler_6 = () => {
    $$invalidate(19, PageSelected = PageSelected + 2);
    SelectPage();
  };
  const click_handler_7 = () => {
    $$invalidate(19, PageSelected = PageSelected + 3);
    SelectPage();
  };
  const click_handler_8 = () => {
    $$invalidate(19, PageSelected = PageSelected + 4);
    SelectPage();
  };
  const click_handler_9 = () => {
    if (PageSelected < TotalPages) {
      $$invalidate(19, PageSelected = PageSelected + 1);
      SelectPage();
    }
  };
  const click_handler_10 = () => {
    $$invalidate(19, PageSelected = TotalPages);
    SelectPage();
  };
  const change_handler_3 = (e) => {
    $$invalidate(1, PageSizeSelected = e.target.value);
    FilterData();
  };
  const click_handler_11 = (e) => {
    $$invalidate(16, ShowDialogColumn = false);
  };
  const click_handler_12 = (e) => {
    $$invalidate(16, ShowDialogColumn = false);
  };
  $$self.$$set = ($$props2) => {
    if ("RawDataTable" in $$props2)
      $$invalidate(39, RawDataTable = $$props2.RawDataTable);
    if ("SelectionType" in $$props2)
      $$invalidate(0, SelectionType = $$props2.SelectionType);
    if ("columns" in $$props2)
      $$invalidate(2, columns = $$props2.columns);
    if ("url" in $$props2)
      $$invalidate(3, url = $$props2.url);
    if ("params" in $$props2)
      $$invalidate(41, params = $$props2.params);
    if ("ShowNewButton" in $$props2)
      $$invalidate(4, ShowNewButton = $$props2.ShowNewButton);
    if ("ShowEditButton" in $$props2)
      $$invalidate(5, ShowEditButton = $$props2.ShowEditButton);
    if ("ShowSelectionButton" in $$props2)
      $$invalidate(6, ShowSelectionButton = $$props2.ShowSelectionButton);
    if ("ShowExportButton" in $$props2)
      $$invalidate(7, ShowExportButton = $$props2.ShowExportButton);
    if ("iconExport" in $$props2)
      $$invalidate(8, iconExport = $$props2.iconExport);
    if ("rowClassFunction" in $$props2)
      $$invalidate(9, rowClassFunction = $$props2.rowClassFunction);
    if ("IntervalRefreshSelected" in $$props2)
      $$invalidate(40, IntervalRefreshSelected = $$props2.IntervalRefreshSelected);
    if ("PageSize" in $$props2)
      $$invalidate(10, PageSize = $$props2.PageSize);
    if ("PageSizeSelected" in $$props2)
      $$invalidate(1, PageSizeSelected = $$props2.PageSizeSelected);
    if ("relatedTablesForAutoRefresh" in $$props2)
      $$invalidate(42, relatedTablesForAutoRefresh = $$props2.relatedTablesForAutoRefresh);
    if ("fileNameExport" in $$props2)
      $$invalidate(43, fileNameExport = $$props2.fileNameExport);
    if ("$$scope" in $$props2)
      $$invalidate(69, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    XLSX: xlsx_exports,
    createEventDispatcher,
    onDestroy,
    onMount,
    uFetch: import_universal_fetch.default,
    DT: DateTime_default,
    Auto: Auto_default,
    DateTime,
    storeChangedTables,
    sha256,
    Level: Level_default,
    RawDataTable,
    SelectionType,
    columns,
    url,
    params,
    ShowNewButton,
    ShowEditButton,
    ShowSelectionButton,
    ShowExportButton,
    iconExport,
    rowClassFunction,
    FetchData,
    dispatch,
    DataTable,
    SelectedRows,
    text_search,
    loading,
    showEdit,
    ColumnSort,
    ShowDialogColumn,
    timeRemainingToRefresh,
    LastFetchResponse,
    IntervalRefresh,
    IntervalRefreshSelected,
    PageSize,
    PageSizeSelected,
    relatedTablesForAutoRefresh,
    fileNameExport,
    PageSelected,
    totalFilteredRows,
    TotalPages,
    paginatedData,
    SelectAll,
    orderASC,
    internal_columns,
    hash,
    OnSelection,
    ArrayChunk,
    SetColumns,
    RowIsSelected,
    GetSelectedRows,
    ExportTable,
    auto_refresh_by_table_changed_request,
    auto_refresh,
    hash_last_data,
    check_changes_data,
    ChangeIntervalRefresh,
    SortColumn,
    HClickCell,
    HClickEditRow,
    HClickNew,
    HClickHeader,
    handleClickSearch,
    handleChangeSelectAll,
    handleExportSelection,
    FilterData,
    Pagination,
    SelectPage,
    HandleOnClickEdit,
    HandleOnRowSelected,
    ProcessRawData,
    GetDataTable
  });
  $$self.$inject_state = ($$props2) => {
    if ("RawDataTable" in $$props2)
      $$invalidate(39, RawDataTable = $$props2.RawDataTable);
    if ("SelectionType" in $$props2)
      $$invalidate(0, SelectionType = $$props2.SelectionType);
    if ("columns" in $$props2)
      $$invalidate(2, columns = $$props2.columns);
    if ("url" in $$props2)
      $$invalidate(3, url = $$props2.url);
    if ("params" in $$props2)
      $$invalidate(41, params = $$props2.params);
    if ("ShowNewButton" in $$props2)
      $$invalidate(4, ShowNewButton = $$props2.ShowNewButton);
    if ("ShowEditButton" in $$props2)
      $$invalidate(5, ShowEditButton = $$props2.ShowEditButton);
    if ("ShowSelectionButton" in $$props2)
      $$invalidate(6, ShowSelectionButton = $$props2.ShowSelectionButton);
    if ("ShowExportButton" in $$props2)
      $$invalidate(7, ShowExportButton = $$props2.ShowExportButton);
    if ("iconExport" in $$props2)
      $$invalidate(8, iconExport = $$props2.iconExport);
    if ("rowClassFunction" in $$props2)
      $$invalidate(9, rowClassFunction = $$props2.rowClassFunction);
    if ("DataTable" in $$props2)
      $$invalidate(11, DataTable = $$props2.DataTable);
    if ("SelectedRows" in $$props2)
      $$invalidate(45, SelectedRows = $$props2.SelectedRows);
    if ("text_search" in $$props2)
      $$invalidate(12, text_search = $$props2.text_search);
    if ("loading" in $$props2)
      $$invalidate(13, loading = $$props2.loading);
    if ("showEdit" in $$props2)
      $$invalidate(14, showEdit = $$props2.showEdit);
    if ("ColumnSort" in $$props2)
      $$invalidate(15, ColumnSort = $$props2.ColumnSort);
    if ("ShowDialogColumn" in $$props2)
      $$invalidate(16, ShowDialogColumn = $$props2.ShowDialogColumn);
    if ("timeRemainingToRefresh" in $$props2)
      $$invalidate(17, timeRemainingToRefresh = $$props2.timeRemainingToRefresh);
    if ("LastFetchResponse" in $$props2)
      $$invalidate(18, LastFetchResponse = $$props2.LastFetchResponse);
    if ("IntervalRefresh" in $$props2)
      IntervalRefresh = $$props2.IntervalRefresh;
    if ("IntervalRefreshSelected" in $$props2)
      $$invalidate(40, IntervalRefreshSelected = $$props2.IntervalRefreshSelected);
    if ("PageSize" in $$props2)
      $$invalidate(10, PageSize = $$props2.PageSize);
    if ("PageSizeSelected" in $$props2)
      $$invalidate(1, PageSizeSelected = $$props2.PageSizeSelected);
    if ("relatedTablesForAutoRefresh" in $$props2)
      $$invalidate(42, relatedTablesForAutoRefresh = $$props2.relatedTablesForAutoRefresh);
    if ("fileNameExport" in $$props2)
      $$invalidate(43, fileNameExport = $$props2.fileNameExport);
    if ("PageSelected" in $$props2)
      $$invalidate(19, PageSelected = $$props2.PageSelected);
    if ("totalFilteredRows" in $$props2)
      $$invalidate(20, totalFilteredRows = $$props2.totalFilteredRows);
    if ("TotalPages" in $$props2)
      $$invalidate(21, TotalPages = $$props2.TotalPages);
    if ("paginatedData" in $$props2)
      $$invalidate(22, paginatedData = $$props2.paginatedData);
    if ("SelectAll" in $$props2)
      SelectAll = $$props2.SelectAll;
    if ("orderASC" in $$props2)
      $$invalidate(23, orderASC = $$props2.orderASC);
    if ("internal_columns" in $$props2)
      $$invalidate(24, internal_columns = $$props2.internal_columns);
    if ("auto_refresh_by_table_changed_request" in $$props2)
      auto_refresh_by_table_changed_request = $$props2.auto_refresh_by_table_changed_request;
    if ("auto_refresh" in $$props2)
      auto_refresh = $$props2.auto_refresh;
    if ("hash_last_data" in $$props2)
      hash_last_data = $$props2.hash_last_data;
    if ("check_changes_data" in $$props2)
      check_changes_data = $$props2.check_changes_data;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*SelectedRows*/
    16384) {
      $:
        SelectedRows, OnSelection();
    }
  };
  return [
    SelectionType,
    PageSizeSelected,
    columns,
    url,
    ShowNewButton,
    ShowEditButton,
    ShowSelectionButton,
    ShowExportButton,
    iconExport,
    rowClassFunction,
    PageSize,
    DataTable,
    text_search,
    loading,
    showEdit,
    ColumnSort,
    ShowDialogColumn,
    timeRemainingToRefresh,
    LastFetchResponse,
    PageSelected,
    totalFilteredRows,
    TotalPages,
    paginatedData,
    orderASC,
    internal_columns,
    RowIsSelected,
    ChangeIntervalRefresh,
    HClickCell,
    HClickEditRow,
    HClickNew,
    HClickHeader,
    handleClickSearch,
    handleChangeSelectAll,
    handleExportSelection,
    FilterData,
    SelectPage,
    HandleOnClickEdit,
    HandleOnRowSelected,
    $$slots,
    RawDataTable,
    IntervalRefreshSelected,
    params,
    relatedTablesForAutoRefresh,
    fileNameExport,
    GetSelectedRows,
    SelectedRows,
    slots,
    change_handler,
    change_handler_1,
    change_handler_2,
    input_input_handler,
    switch_instance_row_binding,
    switch_instance_value_binding,
    click_handler,
    switch_instance_row_binding_1,
    switch_instance_value_binding_1,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6,
    click_handler_7,
    click_handler_8,
    click_handler_9,
    click_handler_10,
    change_handler_3,
    click_handler_11,
    click_handler_12,
    $$scope
  ];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance9,
      create_fragment9,
      safe_not_equal,
      {
        RawDataTable: 39,
        SelectionType: 0,
        columns: 2,
        url: 3,
        params: 41,
        ShowNewButton: 4,
        ShowEditButton: 5,
        ShowSelectionButton: 6,
        ShowExportButton: 7,
        iconExport: 8,
        rowClassFunction: 9,
        IntervalRefreshSelected: 40,
        PageSize: 10,
        PageSizeSelected: 1,
        relatedTablesForAutoRefresh: 42,
        fileNameExport: 43,
        GetSelectedRows: 44
      },
      add_css5,
      [-1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment9.name
    });
  }
  get RawDataTable() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set RawDataTable(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get SelectionType() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set SelectionType(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columns() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columns(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get url() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get params() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set params(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ShowNewButton() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ShowNewButton(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ShowEditButton() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ShowEditButton(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ShowSelectionButton() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ShowSelectionButton(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ShowExportButton() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ShowExportButton(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconExport() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconExport(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowClassFunction() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowClassFunction(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get IntervalRefreshSelected() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set IntervalRefreshSelected(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get PageSize() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set PageSize(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get PageSizeSelected() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set PageSizeSelected(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get relatedTablesForAutoRefresh() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set relatedTablesForAutoRefresh(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fileNameExport() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fileNameExport(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get GetSelectedRows() {
    return this.$$.ctx[44];
  }
  set GetSelectedRows(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_default = Table;

// node_modules/@edwinspire/svelte-components/dist/Dialog/Modal.svelte
var file10 = "node_modules/@edwinspire/svelte-components/dist/Dialog/Modal.svelte";
function add_css6(target) {
  append_styles(target, "svelte-12rollf", ".modal-card-foot.svelte-12rollf,.modal-card-head.svelte-12rollf{padding:10px !important}.modal-card-title.svelte-12rollf{font-size:1rem !important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW9kYWwuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWtEQywrQkFBZ0IsQ0FDaEIsK0JBQWlCLENBQ2hCLE9BQU8sQ0FBRSxJQUFJLENBQUMsVUFDZixDQUNBLGdDQUFrQixDQUNqQixTQUFTLENBQUUsSUFBSSxDQUFDLFVBQ2pCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIk1vZGFsLnN2ZWx0ZSJdfQ== */");
}
var get_label_cancel_slot_changes = (dirty) => ({});
var get_label_cancel_slot_context = (ctx) => ({});
var get_label_ok_slot_changes = (dirty) => ({});
var get_label_ok_slot_context = (ctx) => ({});
var get_body_slot_changes = (dirty) => ({});
var get_body_slot_context = (ctx) => ({});
var get_title_slot_changes = (dirty) => ({});
var get_title_slot_context = (ctx) => ({});
function fallback_block_1(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Accept");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Accept");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(35:26) Accept",
    ctx
  });
  return block;
}
function fallback_block2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Cancel");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Cancel");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(44:30) Cancel",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let header;
  let p;
  let b;
  let t1;
  let button0;
  let t2;
  let section;
  let t3;
  let footer;
  let button1;
  let t4;
  let button2;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[3].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_title_slot_context
  );
  const body_slot_template = (
    /*#slots*/
    ctx[3].body
  );
  const body_slot = create_slot(
    body_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_body_slot_context
  );
  const label_ok_slot_template = (
    /*#slots*/
    ctx[3]["label-ok"]
  );
  const label_ok_slot = create_slot(
    label_ok_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_label_ok_slot_context
  );
  const label_ok_slot_or_fallback = label_ok_slot || fallback_block_1(ctx);
  const label_cancel_slot_template = (
    /*#slots*/
    ctx[3]["label-cancel"]
  );
  const label_cancel_slot = create_slot(
    label_cancel_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_label_cancel_slot_context
  );
  const label_cancel_slot_or_fallback = label_cancel_slot || fallback_block2(ctx);
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      header = element("header");
      p = element("p");
      b = element("b");
      if (title_slot)
        title_slot.c();
      t1 = space();
      button0 = element("button");
      t2 = space();
      section = element("section");
      if (body_slot)
        body_slot.c();
      t3 = space();
      footer = element("footer");
      button1 = element("button");
      if (label_ok_slot_or_fallback)
        label_ok_slot_or_fallback.c();
      t4 = space();
      button2 = element("button");
      if (label_cancel_slot_or_fallback)
        label_cancel_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      header = claim_element(div1_nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      p = claim_element(header_nodes, "P", { class: true });
      var p_nodes = children(p);
      b = claim_element(p_nodes, "B", {});
      var b_nodes = children(b);
      if (title_slot)
        title_slot.l(b_nodes);
      b_nodes.forEach(detach_dev);
      p_nodes.forEach(detach_dev);
      t1 = claim_space(header_nodes);
      button0 = claim_element(header_nodes, "BUTTON", { class: true, "aria-label": true });
      children(button0).forEach(detach_dev);
      header_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      section = claim_element(div1_nodes, "SECTION", { class: true });
      var section_nodes = children(section);
      if (body_slot)
        body_slot.l(section_nodes);
      section_nodes.forEach(detach_dev);
      t3 = claim_space(div1_nodes);
      footer = claim_element(div1_nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      button1 = claim_element(footer_nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      if (label_ok_slot_or_fallback)
        label_ok_slot_or_fallback.l(button1_nodes);
      button1_nodes.forEach(detach_dev);
      t4 = claim_space(footer_nodes);
      button2 = claim_element(footer_nodes, "BUTTON", { class: true });
      var button2_nodes = children(button2);
      if (label_cancel_slot_or_fallback)
        label_cancel_slot_or_fallback.l(button2_nodes);
      button2_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "modal-background");
      add_location(div0, file10, 7, 1, 182);
      add_location(b, file10, 11, 4, 347);
      attr_dev(p, "class", "modal-card-title has-text-white svelte-12rollf");
      add_location(p, file10, 10, 3, 299);
      attr_dev(button0, "class", "delete");
      attr_dev(button0, "aria-label", "close");
      add_location(button0, file10, 15, 3, 398);
      attr_dev(header, "class", "modal-card-head has-background-dark svelte-12rollf");
      add_location(header, file10, 9, 2, 243);
      attr_dev(section, "class", "modal-card-body");
      add_location(section, file10, 24, 2, 545);
      attr_dev(button1, "class", "button is-success is-small");
      add_location(button1, file10, 28, 3, 674);
      attr_dev(button2, "class", "button is-small");
      add_location(button2, file10, 36, 3, 836);
      attr_dev(footer, "class", "modal-card-foot has-background-dark svelte-12rollf");
      add_location(footer, file10, 27, 2, 618);
      attr_dev(div1, "class", "modal-card");
      add_location(div1, file10, 8, 1, 216);
      attr_dev(div2, "class", "modal");
      toggle_class(
        div2,
        "is-active",
        /*Show*/
        ctx[0]
      );
      add_location(div2, file10, 6, 0, 138);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, header);
      append_hydration_dev(header, p);
      append_hydration_dev(p, b);
      if (title_slot) {
        title_slot.m(b, null);
      }
      append_hydration_dev(header, t1);
      append_hydration_dev(header, button0);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div1, section);
      if (body_slot) {
        body_slot.m(section, null);
      }
      append_hydration_dev(div1, t3);
      append_hydration_dev(div1, footer);
      append_hydration_dev(footer, button1);
      if (label_ok_slot_or_fallback) {
        label_ok_slot_or_fallback.m(button1, null);
      }
      append_hydration_dev(footer, t4);
      append_hydration_dev(footer, button2);
      if (label_cancel_slot_or_fallback) {
        label_cancel_slot_or_fallback.m(button2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*click_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*click_handler_1*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button2,
            "click",
            /*click_handler_2*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_title_slot_changes
            ),
            get_title_slot_context
          );
        }
      }
      if (body_slot) {
        if (body_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            body_slot,
            body_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              body_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_body_slot_changes
            ),
            get_body_slot_context
          );
        }
      }
      if (label_ok_slot) {
        if (label_ok_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            label_ok_slot,
            label_ok_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              label_ok_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_label_ok_slot_changes
            ),
            get_label_ok_slot_context
          );
        }
      }
      if (label_cancel_slot) {
        if (label_cancel_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            label_cancel_slot,
            label_cancel_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              label_cancel_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_label_cancel_slot_changes
            ),
            get_label_cancel_slot_context
          );
        }
      }
      if (!current || dirty & /*Show*/
      1) {
        toggle_class(
          div2,
          "is-active",
          /*Show*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      transition_in(body_slot, local);
      transition_in(label_ok_slot_or_fallback, local);
      transition_in(label_cancel_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      transition_out(body_slot, local);
      transition_out(label_ok_slot_or_fallback, local);
      transition_out(label_cancel_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (title_slot)
        title_slot.d(detaching);
      if (body_slot)
        body_slot.d(detaching);
      if (label_ok_slot_or_fallback)
        label_ok_slot_or_fallback.d(detaching);
      if (label_cancel_slot_or_fallback)
        label_cancel_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, ["title", "body", "label-ok", "label-cancel"]);
  const dispatch = createEventDispatcher();
  let { Show = false } = $$props;
  const writable_props = ["Show"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Modal> was created with unknown prop '${key}'`);
  });
  const click_handler = (e) => {
    $$invalidate(0, Show = false);
    dispatch("cancel", e);
  };
  const click_handler_1 = (e) => {
    dispatch("ok", e);
  };
  const click_handler_2 = (e) => {
    $$invalidate(0, Show = false);
    dispatch("cancel", e);
  };
  $$self.$$set = ($$props2) => {
    if ("Show" in $$props2)
      $$invalidate(0, Show = $$props2.Show);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ createEventDispatcher, dispatch, Show });
  $$self.$inject_state = ($$props2) => {
    if ("Show" in $$props2)
      $$invalidate(0, Show = $$props2.Show);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Show,
    dispatch,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { Show: 0 }, add_css6);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment10.name
    });
  }
  get Show() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Show(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Modal_default = Modal;

// node_modules/@edwinspire/svelte-components/dist/Input/Predictive.svelte
var file11 = "node_modules/@edwinspire/svelte-components/dist/Input/Predictive.svelte";
function add_css7(target) {
  append_styles(target, "svelte-f3hfl6", ".dropdown.svelte-f3hfl6{position:relative}.dropdown-list.svelte-f3hfl6{position:absolute;top:100%;left:0;width:100%;max-height:200px;overflow-y:auto;background-color:#fff;border:1px solid #ccc;border-top:none;border-radius:4px;z-index:999}.dropdown-list-item.svelte-f3hfl6{padding:8px;cursor:pointer}.dropdown-list-item.is-active.svelte-f3hfl6{background-color:#f5f5f5}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJlZGljdGl2ZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBc0lFLHVCQUFVLENBQ1IsUUFBUSxDQUFFLFFBQ1osQ0FFQSw0QkFBZSxDQUNiLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxJQUFJLENBQ1QsSUFBSSxDQUFFLENBQUMsQ0FDUCxLQUFLLENBQUUsSUFBSSxDQUNYLFVBQVUsQ0FBRSxLQUFLLENBQ2pCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLGdCQUFnQixDQUFFLElBQUksQ0FDdEIsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUN0QixVQUFVLENBQUUsSUFBSSxDQUNoQixhQUFhLENBQUUsR0FBRyxDQUNsQixPQUFPLENBQUUsR0FDWCxDQUVBLGlDQUFvQixDQUNsQixPQUFPLENBQUUsR0FBRyxDQUNaLE1BQU0sQ0FBRSxPQUNWLENBRUEsbUJBQW1CLHdCQUFXLENBQzVCLGdCQUFnQixDQUFFLE9BQ3BCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlByZWRpY3RpdmUuc3ZlbHRlIl19 */");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  child_ctx[18] = i;
  return child_ctx;
}
function create_if_block8(ctx) {
  let ul;
  let each_value = ensure_array_like_dev(
    /*filteredOptions*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", "dropdown-list menu label is-small svelte-f3hfl6");
      add_location(ul, file11, 113, 12, 3123);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*selectedIndex, handleOptionClick, filteredOptions*/
      84) {
        each_value = ensure_array_like_dev(
          /*filteredOptions*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(113:10) {#if isOpen && filteredOptions.length > 0}",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let li;
  let t0_value = (
    /*option*/
    ctx[16].name + ""
  );
  let t0;
  let t1;
  let li_class_value;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[11](
        /*option*/
        ctx[16]
      )
    );
  }
  const block = {
    c: function create() {
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      t0 = claim_text(li_nodes, t0_value);
      t1 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "class", li_class_value = "dropdown-list-item menu-item " + /*i*/
      (ctx[18] === /*selectedIndex*/
      ctx[4] ? "is-active" : "") + " svelte-f3hfl6");
      add_location(li, file11, 115, 16, 3237);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, t0);
      append_hydration_dev(li, t1);
      if (!mounted) {
        dispose = listen_dev(li, "click", click_handler_1, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*filteredOptions*/
      4 && t0_value !== (t0_value = /*option*/
      ctx[16].name + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*selectedIndex*/
      16 && li_class_value !== (li_class_value = "dropdown-list-item menu-item " + /*i*/
      (ctx[18] === /*selectedIndex*/
      ctx[4] ? "is-active" : "") + " svelte-f3hfl6")) {
        attr_dev(li, "class", li_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(115:14) {#each filteredOptions as option, i}",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let div4;
  let div0;
  let label0;
  let t0;
  let t1;
  let div3;
  let div2;
  let div1;
  let label1;
  let span1;
  let input;
  let t2;
  let span0;
  let i;
  let t3;
  let mounted;
  let dispose;
  let if_block = (
    /*isOpen*/
    ctx[3] && /*filteredOptions*/
    ctx[2].length > 0 && create_if_block8(ctx)
  );
  const block = {
    c: function create() {
      div4 = element("div");
      div0 = element("div");
      label0 = element("label");
      t0 = text(
        /*label*/
        ctx[0]
      );
      t1 = space();
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      label1 = element("label");
      span1 = element("span");
      input = element("input");
      t2 = space();
      span0 = element("span");
      i = element("i");
      t3 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div4 = claim_element(nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div0 = claim_element(div4_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      label0 = claim_element(div0_nodes, "LABEL", { class: true });
      var label0_nodes = children(label0);
      t0 = claim_text(
        label0_nodes,
        /*label*/
        ctx[0]
      );
      label0_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      label1 = claim_element(div1_nodes, "LABEL", { class: true });
      var label1_nodes = children(label1);
      span1 = claim_element(label1_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      input = claim_element(span1_nodes, "INPUT", { class: true, type: true });
      t2 = claim_space(span1_nodes);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      i = claim_element(span0_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      t3 = claim_space(label1_nodes);
      if (if_block)
        if_block.l(label1_nodes);
      label1_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label0, "class", "label");
      add_location(label0, file11, 90, 4, 2294);
      attr_dev(div0, "class", "field-label is-small");
      add_location(div0, file11, 88, 2, 2194);
      attr_dev(input, "class", "input is-small");
      attr_dev(input, "type", "text");
      input.value = /*inputValue*/
      ctx[1];
      add_location(input, file11, 98, 12, 2588);
      attr_dev(i, "class", "fa-solid fa-chevron-down");
      add_location(i, file11, 108, 14, 2980);
      attr_dev(span0, "class", "icon is-small is-right");
      add_location(span0, file11, 107, 12, 2928);
      attr_dev(span1, "class", "control has-icons-right");
      add_location(span1, file11, 97, 10, 2537);
      attr_dev(label1, "class", "dropdown svelte-f3hfl6");
      add_location(label1, file11, 96, 8, 2502);
      attr_dev(div1, "class", "control");
      add_location(div1, file11, 94, 6, 2407);
      attr_dev(div2, "class", "field is-narrow");
      add_location(div2, file11, 93, 4, 2371);
      attr_dev(div3, "class", "field-body");
      add_location(div3, file11, 92, 2, 2342);
      attr_dev(div4, "class", "field is-horizontal");
      add_location(div4, file11, 87, 0, 2158);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div4, anchor);
      append_hydration_dev(div4, div0);
      append_hydration_dev(div0, label0);
      append_hydration_dev(label0, t0);
      append_hydration_dev(div4, t1);
      append_hydration_dev(div4, div3);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, label1);
      append_hydration_dev(label1, span1);
      append_hydration_dev(span1, input);
      append_hydration_dev(span1, t2);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span0, i);
      append_hydration_dev(label1, t3);
      if (if_block)
        if_block.m(label1, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*handleInput*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*handleDropdownToggle*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*handleKeyDown*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*label*/
      1)
        set_data_dev(
          t0,
          /*label*/
          ctx2[0]
        );
      if (dirty & /*inputValue*/
      2 && input.value !== /*inputValue*/
      ctx2[1]) {
        prop_dev(
          input,
          "value",
          /*inputValue*/
          ctx2[1]
        );
      }
      if (
        /*isOpen*/
        ctx2[3] && /*filteredOptions*/
        ctx2[2].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block8(ctx2);
          if_block.c();
          if_block.m(label1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div4);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Predictive", slots, []);
  let { label = "" } = $$props;
  let inputValue = "";
  let { options = [
    { name: "Apple", value: 0 },
    { name: "Banana", value: 1 },
    { name: "Cherry", value: 2 },
    { name: "Grape", value: 3 },
    { name: "Orange", value: 4 },
    { name: "Orange1", value: 5 },
    { name: "Orange2", value: 6 },
    { name: "Orange3", value: 7 },
    { name: "Orange4", value: 8 },
    { name: "Orange5", value: 9 },
    { name: "Orange6", value: 10 }
  ] } = $$props;
  let filteredOptions = [];
  let isOpen = false;
  let selectedIndex = -1;
  const dispatch = createEventDispatcher();
  function handleInput(event) {
    $$invalidate(1, inputValue = event.target.value);
    filterOptions();
  }
  function filterOptions() {
    $$invalidate(2, filteredOptions = options.filter((option) => option.name.toLowerCase().includes(inputValue.toLowerCase())));
    $$invalidate(4, selectedIndex = -1);
  }
  function handleOptionClick(option) {
    $$invalidate(1, inputValue = option.name);
    dispatch("select", option);
    setTimeout(
      () => {
        $$invalidate(3, isOpen = false);
      },
      0
    );
  }
  function handleDropdownToggle() {
    $$invalidate(3, isOpen = !isOpen);
    if (isOpen) {
      filterOptions();
    }
  }
  function handleOptionSelect(option) {
    $$invalidate(1, inputValue = option.name);
    $$invalidate(3, isOpen = false);
    dispatch("select", option);
  }
  function handleKeyDown(event) {
    if (isOpen) {
      if (event.key === "ArrowUp") {
        event.preventDefault();
        $$invalidate(4, selectedIndex = Math.max(selectedIndex - 1, 0));
      } else if (event.key === "ArrowDown") {
        event.preventDefault();
        $$invalidate(4, selectedIndex = Math.min(selectedIndex + 1, filteredOptions.length - 1));
      } else if (event.key === "Enter" && selectedIndex !== -1) {
        event.preventDefault();
        handleOptionSelect(filteredOptions[selectedIndex]);
      }
    }
  }
  function handleClickOutside(event) {
    if (isOpen && !event.target.closest(".dropdown")) {
      $$invalidate(3, isOpen = false);
    }
  }
  onMount(() => {
    window.addEventListener("click", handleClickOutside);
  });
  onDestroy(() => {
  });
  const writable_props = ["label", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Predictive> was created with unknown prop '${key}'`);
  });
  const click_handler = () => {
    if (!isOpen)
      handleDropdownToggle();
  };
  const click_handler_1 = (option) => handleOptionClick(option);
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(0, label = $$props2.label);
    if ("options" in $$props2)
      $$invalidate(9, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    label,
    inputValue,
    options,
    filteredOptions,
    isOpen,
    selectedIndex,
    dispatch,
    handleInput,
    filterOptions,
    handleOptionClick,
    handleDropdownToggle,
    handleOptionSelect,
    handleKeyDown,
    handleClickOutside
  });
  $$self.$inject_state = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(0, label = $$props2.label);
    if ("inputValue" in $$props2)
      $$invalidate(1, inputValue = $$props2.inputValue);
    if ("options" in $$props2)
      $$invalidate(9, options = $$props2.options);
    if ("filteredOptions" in $$props2)
      $$invalidate(2, filteredOptions = $$props2.filteredOptions);
    if ("isOpen" in $$props2)
      $$invalidate(3, isOpen = $$props2.isOpen);
    if ("selectedIndex" in $$props2)
      $$invalidate(4, selectedIndex = $$props2.selectedIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    label,
    inputValue,
    filteredOptions,
    isOpen,
    selectedIndex,
    handleInput,
    handleOptionClick,
    handleDropdownToggle,
    handleKeyDown,
    options,
    click_handler,
    click_handler_1
  ];
}
var Predictive = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { label: 0, options: 9 }, add_css7);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Predictive",
      options,
      id: create_fragment11.name
    });
  }
  get label() {
    throw new Error("<Predictive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Predictive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Predictive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Predictive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Predictive_default = Predictive;

// node_modules/@edwinspire/svelte-components/dist/D3/Plotter.svelte
var { console: console_12 } = globals;
var file12 = "node_modules/@edwinspire/svelte-components/dist/D3/Plotter.svelte";
function add_css8(target) {
  append_styles(target, "svelte-1hxv1ey", "\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGxvdHRlci5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvaG9tZS9lZHdpbnNwaXJlL0RvY3VtZW50b3MvRGVzYXJyb2xsby9saWJPcGVuRnVzaW9uQVBJR1VJL25vZGVfbW9kdWxlcy9AZWR3aW5zcGlyZS9zdmVsdGUtY29tcG9uZW50cy9kaXN0L0QzL1Bsb3R0ZXIuc3ZlbHRlIl19 */");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[42] = list[i];
  child_ctx[44] = i;
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[45] = list[i];
  return child_ctx;
}
function create_l01_slot_1(ctx) {
  let span;
  let textContent = "Hola";
  const block = {
    c: function create() {
      span = element("span");
      span.textContent = textContent;
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-175aoxg")
        span.textContent = textContent;
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "l01");
      add_location(span, file12, 182, 1, 4608);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_l01_slot_1.name,
    type: "slot",
    source: "(183:1) ",
    ctx
  });
  return block;
}
function create_if_block_113(ctx) {
  let button;
  let textContent = "Reset Zoom";
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      button.textContent = textContent;
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(button) !== "svelte-94lmf7")
        button.textContent = textContent;
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "button");
      add_location(button, file12, 201, 4, 5008);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*resetZoom*/
          ctx[21],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_113.name,
    type: "if",
    source: "(201:3) {#if showResetButton}",
    ctx
  });
  return block;
}
function create_else_block7(ctx) {
  let i;
  const block = {
    c: function create() {
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", "fa-solid fa-lock");
      add_location(i, file12, 214, 6, 5346);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(i);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block7.name,
    type: "else",
    source: "(214:5) {:else}",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let i;
  const block = {
    c: function create() {
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", "fa-solid fa-lock-open");
      add_location(i, file12, 212, 6, 5291);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(i);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(212:5) {#if refresh}",
    ctx
  });
  return block;
}
function create_r01_slot2(ctx) {
  let span4;
  let div;
  let button0;
  let span0;
  let i;
  let t0;
  let span1;
  let textContent = "SnapShot";
  let t2;
  let t3;
  let button1;
  let span2;
  let t4;
  let span3;
  let textContent_1 = "Refresh";
  let button1_class_value;
  let mounted;
  let dispose;
  let if_block0 = (
    /*showResetButton*/
    ctx[19] && create_if_block_113(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*refresh*/
      ctx2[3]
    )
      return create_if_block9;
    return create_else_block7;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block1 = current_block_type(ctx);
  const block = {
    c: function create() {
      span4 = element("span");
      div = element("div");
      button0 = element("button");
      span0 = element("span");
      i = element("i");
      t0 = space();
      span1 = element("span");
      span1.textContent = textContent;
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      button1 = element("button");
      span2 = element("span");
      if_block1.c();
      t4 = space();
      span3 = element("span");
      span3.textContent = textContent_1;
      this.h();
    },
    l: function claim(nodes) {
      span4 = claim_element(nodes, "SPAN", { slot: true });
      var span4_nodes = children(span4);
      div = claim_element(span4_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      button0 = claim_element(div_nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      span0 = claim_element(button0_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      i = claim_element(span0_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      span0_nodes.forEach(detach_dev);
      t0 = claim_space(button0_nodes);
      span1 = claim_element(button0_nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span1) !== "svelte-iuv2bq")
        span1.textContent = textContent;
      button0_nodes.forEach(detach_dev);
      t2 = claim_space(div_nodes);
      if (if_block0)
        if_block0.l(div_nodes);
      t3 = claim_space(div_nodes);
      button1 = claim_element(div_nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      span2 = claim_element(button1_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      if_block1.l(span2_nodes);
      span2_nodes.forEach(detach_dev);
      t4 = claim_space(button1_nodes);
      span3 = claim_element(button1_nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span3) !== "svelte-27y9ff")
        span3.textContent = textContent_1;
      button1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      span4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", "fa-solid fa-camera");
      add_location(i, file12, 195, 5, 4894);
      attr_dev(span0, "class", "icon is-small");
      add_location(span0, file12, 194, 4, 4860);
      add_location(span1, file12, 197, 4, 4943);
      attr_dev(button0, "class", "button is-small");
      add_location(button0, file12, 186, 3, 4694);
      attr_dev(span2, "class", "icon is-small");
      add_location(span2, file12, 210, 4, 5237);
      add_location(span3, file12, 217, 4, 5404);
      attr_dev(button1, "class", button1_class_value = /*refresh*/
      ctx[3] ? "button is-small is-success" : "button is-small is-danger");
      add_location(button1, file12, 204, 3, 5085);
      attr_dev(div, "class", "buttons are-small");
      add_location(div, file12, 185, 2, 4659);
      attr_dev(span4, "slot", "r01");
      add_location(span4, file12, 184, 1, 4639);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span4, anchor);
      append_hydration_dev(span4, div);
      append_hydration_dev(div, button0);
      append_hydration_dev(button0, span0);
      append_hydration_dev(span0, i);
      append_hydration_dev(button0, t0);
      append_hydration_dev(button0, span1);
      append_hydration_dev(div, t2);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t3);
      append_hydration_dev(div, button1);
      append_hydration_dev(button1, span2);
      if_block1.m(span2, null);
      append_hydration_dev(button1, t4);
      append_hydration_dev(button1, span3);
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*click_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*click_handler_1*/
            ctx[26],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*showResetButton*/
        ctx2[19]
      )
        if_block0.p(ctx2, dirty);
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(span2, null);
        }
      }
      if (dirty[0] & /*refresh*/
      8 && button1_class_value !== (button1_class_value = /*refresh*/
      ctx2[3] ? "button is-small is-success" : "button is-small is-danger")) {
        attr_dev(button1, "class", button1_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span4);
      }
      if (if_block0)
        if_block0.d();
      if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_r01_slot2.name,
    type: "slot",
    source: "(185:1) ",
    ctx
  });
  return block;
}
function create_each_block_12(ctx) {
  let option;
  let t0_value = (
    /*ts*/
    ctx[45].label + ""
  );
  let t0;
  let t1;
  let option_value_value;
  const block = {
    c: function create() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t0 = claim_text(option_nodes, t0_value);
      t1 = claim_space(option_nodes);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*ts*/
      ctx[45].value;
      set_input_value(option, option.__value);
      add_location(option, file12, 236, 7, 5806);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t0);
      append_hydration_dev(option, t1);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_12.name,
    type: "each",
    source: "(236:6) {#each TimeSample as ts}",
    ctx
  });
  return block;
}
function create_r02_slot2(ctx) {
  let span1;
  let div;
  let p0;
  let input;
  let t;
  let p1;
  let span0;
  let select;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like_dev(
    /*TimeSample*/
    ctx[20]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      span1 = element("span");
      div = element("div");
      p0 = element("p");
      input = element("input");
      t = space();
      p1 = element("p");
      span0 = element("span");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", { slot: true });
      var span1_nodes = children(span1);
      div = claim_element(span1_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      p0 = claim_element(div_nodes, "P", { class: true });
      var p0_nodes = children(p0);
      input = claim_element(p0_nodes, "INPUT", {
        class: true,
        type: true,
        placeholder: true
      });
      p0_nodes.forEach(detach_dev);
      t = claim_space(div_nodes);
      p1 = claim_element(div_nodes, "P", { class: true });
      var p1_nodes = children(p1);
      span0 = claim_element(p1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      select = claim_element(span0_nodes, "SELECT", {});
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      span0_nodes.forEach(detach_dev);
      p1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", "input is-small");
      attr_dev(input, "type", "number");
      attr_dev(input, "placeholder", "Time sample");
      add_location(input, file12, 225, 4, 5536);
      attr_dev(p0, "class", "control");
      add_location(p0, file12, 224, 3, 5512);
      if (
        /*TimeSampleSelected*/
        ctx[2] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[24].call(select)
        ));
      add_location(select, file12, 234, 5, 5727);
      attr_dev(span0, "class", "select is-small");
      add_location(span0, file12, 233, 4, 5691);
      attr_dev(p1, "class", "control");
      add_location(p1, file12, 232, 3, 5667);
      attr_dev(div, "class", "field has-addons");
      add_location(div, file12, 223, 2, 5478);
      attr_dev(span1, "slot", "r02");
      add_location(span1, file12, 222, 1, 5458);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, div);
      append_hydration_dev(div, p0);
      append_hydration_dev(p0, input);
      set_input_value(
        input,
        /*timeValue*/
        ctx[12]
      );
      append_hydration_dev(div, t);
      append_hydration_dev(div, p1);
      append_hydration_dev(p1, span0);
      append_hydration_dev(span0, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*TimeSampleSelected*/
        ctx[2],
        true
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[23]
          ),
          listen_dev(
            select,
            "change",
            /*select_change_handler*/
            ctx[24]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*timeValue*/
      4096 && to_number(input.value) !== /*timeValue*/
      ctx2[12]) {
        set_input_value(
          input,
          /*timeValue*/
          ctx2[12]
        );
      }
      if (dirty[0] & /*TimeSample*/
      1048576) {
        each_value_1 = ensure_array_like_dev(
          /*TimeSample*/
          ctx2[20]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_12(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty[0] & /*TimeSampleSelected, TimeSample*/
      1048580) {
        select_option(
          select,
          /*TimeSampleSelected*/
          ctx2[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span1);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_r02_slot2.name,
    type: "slot",
    source: "(223:1) ",
    ctx
  });
  return block;
}
function create_each_block4(ctx) {
  let circle;
  let circle_key_value;
  let circle_cx_value;
  let circle_cy_value;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        class: true,
        key: true,
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "class", "dot");
      attr_dev(circle, "key", circle_key_value = /*i*/
      ctx[44]);
      attr_dev(circle, "cx", circle_cx_value = /*x*/
      ctx[13](new Date(
        /*d*/
        ctx[42].date
      )));
      attr_dev(circle, "cy", circle_cy_value = /*y*/
      ctx[14](
        /*d*/
        ctx[42].time
      ));
      attr_dev(circle, "r", "1");
      add_location(circle, file12, 268, 4, 6584);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*x, visibleData*/
      10240 && circle_cx_value !== (circle_cx_value = /*x*/
      ctx2[13](new Date(
        /*d*/
        ctx2[42].date
      )))) {
        attr_dev(circle, "cx", circle_cx_value);
      }
      if (dirty[0] & /*y, visibleData*/
      18432 && circle_cy_value !== (circle_cy_value = /*y*/
      ctx2[14](
        /*d*/
        ctx2[42].time
      ))) {
        attr_dev(circle, "cy", circle_cy_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(circle);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(268:3) {#each visibleData as d, i}",
    ctx
  });
  return block;
}
function create_l01_slot2(ctx) {
  let span;
  let t0;
  let t1;
  let t2;
  let t3_value = 1 / /*TimeSelected*/
  ctx[1] + "";
  let t3;
  let t4;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text("Time between selected endpoints: ");
      t1 = text(
        /*TimeSelected*/
        ctx[1]
      );
      t2 = text("ms | Frecuency: ");
      t3 = text(t3_value);
      t4 = text(" Hz");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { slot: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, "Time between selected endpoints: ");
      t1 = claim_text(
        span_nodes,
        /*TimeSelected*/
        ctx[1]
      );
      t2 = claim_text(span_nodes, "ms | Frecuency: ");
      t3 = claim_text(span_nodes, t3_value);
      t4 = claim_text(span_nodes, " Hz");
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "slot", "l01");
      add_location(span, file12, 274, 2, 6699);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, t1);
      append_hydration_dev(span, t2);
      append_hydration_dev(span, t3);
      append_hydration_dev(span, t4);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*TimeSelected*/
      2)
        set_data_dev(
          t1,
          /*TimeSelected*/
          ctx2[1]
        );
      if (dirty[0] & /*TimeSelected*/
      2 && t3_value !== (t3_value = 1 / /*TimeSelected*/
      ctx2[1] + ""))
        set_data_dev(t3, t3_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_l01_slot2.name,
    type: "slot",
    source: "(275:2) ",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let level0;
  let t0;
  let div;
  let svg;
  let g0;
  let g0_transform_value;
  let g1;
  let g1_transform_value;
  let g2;
  let path;
  let path_d_value;
  let g3;
  let t1;
  let level1;
  let div_resize_listener;
  let current;
  level0 = new Level_default({
    props: {
      $$slots: {
        r02: [create_r02_slot2],
        r01: [create_r01_slot2],
        l01: [create_l01_slot_1]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let each_value = ensure_array_like_dev(
    /*visibleData*/
    ctx[11]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  level1 = new Level_default({
    props: {
      $$slots: { l01: [create_l01_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(level0.$$.fragment);
      t0 = space();
      div = element("div");
      svg = svg_element("svg");
      g0 = svg_element("g");
      g1 = svg_element("g");
      g2 = svg_element("g");
      path = svg_element("path");
      g3 = svg_element("g");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      create_component(level1.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      claim_component(level0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      svg = claim_svg_element(div_nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      g0 = claim_svg_element(svg_nodes, "g", { transform: true });
      children(g0).forEach(detach_dev);
      g1 = claim_svg_element(svg_nodes, "g", { transform: true });
      children(g1).forEach(detach_dev);
      g2 = claim_svg_element(svg_nodes, "g", {
        width: true,
        class: true,
        fill: true,
        "pointer-events": true,
        style: true
      });
      children(g2).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", {
        class: true,
        fill: true,
        stroke: true,
        "stroke-width": true,
        d: true
      });
      children(path).forEach(detach_dev);
      g3 = claim_svg_element(svg_nodes, "g", {
        class: true,
        fill: true,
        stroke: true,
        "stroke-width": true
      });
      var g3_nodes = children(g3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(g3_nodes);
      }
      g3_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      claim_component(level1.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(g0, "transform", g0_transform_value = `translate(0, ${/*height*/
      ctx[16] - /*marginBottom*/
      ctx[17]})`);
      add_location(g0, file12, 248, 2, 6017);
      attr_dev(g1, "transform", g1_transform_value = `translate(${/*marginLeft*/
      ctx[18]}, 0)`);
      add_location(g1, file12, 249, 2, 6093);
      attr_dev(
        g2,
        "width",
        /*width*/
        ctx[0]
      );
      attr_dev(g2, "class", "brush");
      attr_dev(g2, "fill", "none");
      attr_dev(g2, "pointer-events", "all");
      set_style(g2, "-webkit-tap-highlight-color", "rgba(0, 0, 0, 0)");
      add_location(g2, file12, 250, 2, 6158);
      attr_dev(path, "class", "line");
      attr_dev(path, "fill", "none");
      attr_dev(path, "stroke", "currentColor");
      attr_dev(path, "stroke-width", "1.5");
      attr_dev(path, "d", path_d_value = /*line*/
      ctx[15](
        /*visibleData*/
        ctx[11]
      ));
      add_location(path, file12, 258, 2, 6321);
      attr_dev(g3, "class", "dots");
      attr_dev(g3, "fill", "white");
      attr_dev(g3, "stroke", "currentColor");
      attr_dev(g3, "stroke-width", "2.5");
      add_location(g3, file12, 266, 2, 6461);
      attr_dev(
        svg,
        "width",
        /*width*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*height*/
        ctx[16]
      );
      add_location(svg, file12, 247, 1, 5976);
      add_render_callback(() => (
        /*div_elementresize_handler*/
        ctx[33].call(div)
      ));
      add_location(div, file12, 246, 0, 5944);
    },
    m: function mount(target, anchor) {
      mount_component(level0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, svg);
      append_hydration_dev(svg, g0);
      ctx[27](g0);
      append_hydration_dev(svg, g1);
      ctx[28](g1);
      append_hydration_dev(svg, g2);
      ctx[29](g2);
      append_hydration_dev(svg, path);
      ctx[30](path);
      append_hydration_dev(svg, g3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(g3, null);
        }
      }
      ctx[31](g3);
      ctx[32](svg);
      append_hydration_dev(div, t1);
      mount_component(level1, div, null);
      div_resize_listener = add_iframe_resize_listener(
        div,
        /*div_elementresize_handler*/
        ctx[33].bind(div)
      );
      current = true;
    },
    p: function update(ctx2, dirty) {
      const level0_changes = {};
      if (dirty[0] & /*TimeSampleSelected, timeValue, refresh, dataSnapshot, visibleData*/
      6412 | dirty[1] & /*$$scope*/
      131072) {
        level0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      level0.$set(level0_changes);
      if (!current || dirty[0] & /*width*/
      1) {
        attr_dev(
          g2,
          "width",
          /*width*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*line, visibleData*/
      34816 && path_d_value !== (path_d_value = /*line*/
      ctx2[15](
        /*visibleData*/
        ctx2[11]
      ))) {
        attr_dev(path, "d", path_d_value);
      }
      if (dirty[0] & /*x, visibleData, y*/
      26624) {
        each_value = ensure_array_like_dev(
          /*visibleData*/
          ctx2[11]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(g3, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty[0] & /*width*/
      1) {
        attr_dev(
          svg,
          "width",
          /*width*/
          ctx2[0]
        );
      }
      const level1_changes = {};
      if (dirty[0] & /*TimeSelected*/
      2 | dirty[1] & /*$$scope*/
      131072) {
        level1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      level1.$set(level1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(level0.$$.fragment, local);
      transition_in(level1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(level0.$$.fragment, local);
      transition_out(level1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(div);
      }
      destroy_component(level0, detaching);
      ctx[27](null);
      ctx[28](null);
      ctx[29](null);
      ctx[30](null);
      destroy_each(each_blocks, detaching);
      ctx[31](null);
      ctx[32](null);
      destroy_component(level1);
      div_resize_listener();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Plotter", slots, []);
  let { dataInput = [{ date: Date.now(), time: 123 }] } = $$props;
  let width = 640;
  let height = 400;
  let marginTop = 20;
  let marginRight = 20;
  let marginBottom = 30;
  let marginLeft = 40;
  let showResetButton = false;
  let TimeSelected = 0;
  let TimeSampleSelected = "FULL";
  let refresh = true;
  let Svg;
  let gx;
  let gy;
  let brush;
  let brushElement;
  let dataSnapshot = [];
  let pathLine;
  let dots;
  let visibleData = [{ date: Date.now(), time: 123 }];
  let TimeSample = [
    { label: "FULL", value: 0 },
    {
      label: "YEARS",
      value: 1e3 * 60 * 60 * 24 * 30 * 12
    },
    {
      label: "MONTHS",
      value: 1e3 * 60 * 60 * 24 * 30
    },
    {
      label: "DAYS",
      value: 1e3 * 60 * 60 * 24
    },
    { label: "HOURS", value: 1e3 * 60 * 60 },
    { label: "MINUTES", value: 1e3 * 60 },
    { label: "SECONDS", value: 1e3 },
    { label: "MILISECONDS", value: 1 }
  ];
  let timeValue = 1;
  let x = time().domain(extent(visibleData, (d) => new Date(d.date))).range([marginLeft, width - marginRight]);
  let y = linear().domain([0, max(visibleData, (d) => d.time)]).range([height - marginBottom, marginTop]);
  let line = line_default().x((d, i) => x(new Date(d.date))).y((d) => y(d.time)).curve(catmullRom_default.alpha(0.1));
  function xy_Axis() {
    $$invalidate(13, x = time().domain(extent(visibleData, (d) => new Date(d.date))).range([marginLeft, width - marginRight]));
    $$invalidate(14, y = linear().domain([0, max(visibleData, (d) => d.time)]).range([height - marginBottom, marginTop]));
    $$invalidate(15, line = line_default().x((d, i) => x(new Date(d.date))).y((d) => y(d.time)).curve(catmullRom_default.alpha(0.1)));
    let GridY = axisLeft(y).tickSize(-width + marginLeft + marginRight).tickSizeOuter(1);
    let GridX = axisBottom(x).tickSize(-height + marginBottom + marginTop).tickSizeOuter(1).tickFormat(timeFormat("%H:%M:%S.%L"));
    select_default(gy).call(GridY).selectAll(".tick line").attr("stroke", "#d1d1e0");
    select_default(gx).call(GridX).selectAll(".tick line").attr("stroke", "#d1d1e0");
  }
  function updateInternalData() {
    if (refresh) {
      if (TimeSampleSelected == "FULL") {
        $$invalidate(11, visibleData = [...dataInput]);
      } else {
        const now = Date.now();
        const lastHour = now - TimeSampleSelected * timeValue;
        $$invalidate(11, visibleData = dataInput.filter((item) => item.date >= lastHour && item.date <= now));
      }
      $$invalidate(11, visibleData);
    }
    xy_Axis();
  }
  let updateChart = (event) => {
    let extent2 = event.selection;
    if (!extent2) {
      if (!idleTimeout)
        return idleTimeout = setTimeout(idled, 350);
      resetZoom();
    } else {
      select_default(
        brushElement
      ).call(brush.move, null);
      const selectedData = visibleData.filter((d) => x(d.date) >= extent2[0] && x(d.date) <= extent2[1]);
      $$invalidate(11, visibleData = [...selectedData]);
      const firstValue = visibleData[0];
      const lastValue = visibleData[visibleData.length - 1];
      $$invalidate(1, TimeSelected = (new Date(lastValue.date) - new Date(firstValue.date)) / 1e3);
      console.log("Calculo: ", firstValue, lastValue, TimeSelected, 1 / TimeSelected);
    }
  };
  let idleTimeout;
  let idled = () => {
    idleTimeout = null;
  };
  function resetZoom() {
    console.log("Reset", dataSnapshot, visibleData);
    $$invalidate(11, visibleData = [...dataSnapshot]);
  }
  onMount(() => {
    brush = brushX().extent([[marginLeft, marginTop], [width - marginRight, height - marginBottom]]).on("end", updateChart);
    select_default(brushElement).call(brush);
    $$invalidate(2, TimeSampleSelected = "FULL");
  });
  const writable_props = ["dataInput"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_12.warn(`<Plotter> was created with unknown prop '${key}'`);
  });
  function input_input_handler() {
    timeValue = to_number(this.value);
    $$invalidate(12, timeValue);
  }
  function select_change_handler() {
    TimeSampleSelected = select_value(this);
    $$invalidate(2, TimeSampleSelected);
    $$invalidate(20, TimeSample);
  }
  const click_handler = () => {
    $$invalidate(3, refresh = false);
    $$invalidate(8, dataSnapshot = [...visibleData]);
    console.log(dataSnapshot);
  };
  const click_handler_1 = () => {
    $$invalidate(3, refresh = !refresh);
  };
  function g0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      gx = $$value;
      $$invalidate(5, gx);
    });
  }
  function g1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      gy = $$value;
      $$invalidate(6, gy);
    });
  }
  function g2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      brushElement = $$value;
      $$invalidate(7, brushElement);
    });
  }
  function path_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      pathLine = $$value;
      $$invalidate(9, pathLine);
    });
  }
  function g3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dots = $$value;
      $$invalidate(10, dots);
    });
  }
  function svg_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      Svg = $$value;
      $$invalidate(4, Svg);
    });
  }
  function div_elementresize_handler() {
    width = this.clientWidth;
    $$invalidate(0, width);
  }
  $$self.$$set = ($$props2) => {
    if ("dataInput" in $$props2)
      $$invalidate(22, dataInput = $$props2.dataInput);
  };
  $$self.$capture_state = () => ({
    d3: src_exports,
    onMount,
    Level: Level_default,
    dataInput,
    width,
    height,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    showResetButton,
    TimeSelected,
    TimeSampleSelected,
    refresh,
    Svg,
    gx,
    gy,
    brush,
    brushElement,
    dataSnapshot,
    pathLine,
    dots,
    visibleData,
    TimeSample,
    timeValue,
    x,
    y,
    line,
    xy_Axis,
    updateInternalData,
    updateChart,
    idleTimeout,
    idled,
    resetZoom
  });
  $$self.$inject_state = ($$props2) => {
    if ("dataInput" in $$props2)
      $$invalidate(22, dataInput = $$props2.dataInput);
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(16, height = $$props2.height);
    if ("marginTop" in $$props2)
      marginTop = $$props2.marginTop;
    if ("marginRight" in $$props2)
      marginRight = $$props2.marginRight;
    if ("marginBottom" in $$props2)
      $$invalidate(17, marginBottom = $$props2.marginBottom);
    if ("marginLeft" in $$props2)
      $$invalidate(18, marginLeft = $$props2.marginLeft);
    if ("showResetButton" in $$props2)
      $$invalidate(19, showResetButton = $$props2.showResetButton);
    if ("TimeSelected" in $$props2)
      $$invalidate(1, TimeSelected = $$props2.TimeSelected);
    if ("TimeSampleSelected" in $$props2)
      $$invalidate(2, TimeSampleSelected = $$props2.TimeSampleSelected);
    if ("refresh" in $$props2)
      $$invalidate(3, refresh = $$props2.refresh);
    if ("Svg" in $$props2)
      $$invalidate(4, Svg = $$props2.Svg);
    if ("gx" in $$props2)
      $$invalidate(5, gx = $$props2.gx);
    if ("gy" in $$props2)
      $$invalidate(6, gy = $$props2.gy);
    if ("brush" in $$props2)
      brush = $$props2.brush;
    if ("brushElement" in $$props2)
      $$invalidate(7, brushElement = $$props2.brushElement);
    if ("dataSnapshot" in $$props2)
      $$invalidate(8, dataSnapshot = $$props2.dataSnapshot);
    if ("pathLine" in $$props2)
      $$invalidate(9, pathLine = $$props2.pathLine);
    if ("dots" in $$props2)
      $$invalidate(10, dots = $$props2.dots);
    if ("visibleData" in $$props2)
      $$invalidate(11, visibleData = $$props2.visibleData);
    if ("TimeSample" in $$props2)
      $$invalidate(20, TimeSample = $$props2.TimeSample);
    if ("timeValue" in $$props2)
      $$invalidate(12, timeValue = $$props2.timeValue);
    if ("x" in $$props2)
      $$invalidate(13, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(14, y = $$props2.y);
    if ("line" in $$props2)
      $$invalidate(15, line = $$props2.line);
    if ("updateChart" in $$props2)
      updateChart = $$props2.updateChart;
    if ("idleTimeout" in $$props2)
      idleTimeout = $$props2.idleTimeout;
    if ("idled" in $$props2)
      idled = $$props2.idled;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*dataInput*/
    4194304) {
      $:
        dataInput, updateInternalData();
    }
  };
  return [
    width,
    TimeSelected,
    TimeSampleSelected,
    refresh,
    Svg,
    gx,
    gy,
    brushElement,
    dataSnapshot,
    pathLine,
    dots,
    visibleData,
    timeValue,
    x,
    y,
    line,
    height,
    marginBottom,
    marginLeft,
    showResetButton,
    TimeSample,
    resetZoom,
    dataInput,
    input_input_handler,
    select_change_handler,
    click_handler,
    click_handler_1,
    g0_binding,
    g1_binding,
    g2_binding,
    path_binding,
    g3_binding,
    svg_binding,
    div_elementresize_handler
  ];
}
var Plotter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { dataInput: 22 }, add_css8, [-1, -1]);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Plotter",
      options,
      id: create_fragment12.name
    });
  }
  get dataInput() {
    throw new Error("<Plotter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dataInput(value) {
    throw new Error("<Plotter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Plotter_default = Plotter;

// node_modules/@edwinspire/svelte-components/dist/Tab/Tab.svelte
var file13 = "node_modules/@edwinspire/svelte-components/dist/Tab/Tab.svelte";
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  child_ctx[9] = list;
  child_ctx[10] = i;
  return child_ctx;
}
function create_else_block8(ctx) {
  let t_1_value = (
    /*item*/
    ctx[8].label + ""
  );
  let t_1;
  const block = {
    c: function create() {
      t_1 = text(t_1_value);
    },
    l: function claim(nodes) {
      t_1 = claim_text(nodes, t_1_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t_1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tabs*/
      1 && t_1_value !== (t_1_value = /*item*/
      ctx2[8].label + ""))
        set_data_dev(t_1, t_1_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block8.name,
    type: "else",
    source: "(37:5) {:else}",
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let span0;
  let i;
  let i_class_value;
  let t0;
  let span1;
  let t1_value = (
    /*item*/
    ctx[8].label + ""
  );
  let t1;
  const block = {
    c: function create() {
      span0 = element("span");
      i = element("i");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      span0 = claim_element(nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      i = claim_element(span0_nodes, "I", { class: true, "aria-hidden": true });
      children(i).forEach(detach_dev);
      span0_nodes.forEach(detach_dev);
      t0 = claim_space(nodes);
      span1 = claim_element(nodes, "SPAN", {});
      var span1_nodes = children(span1);
      t1 = claim_text(span1_nodes, t1_value);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", i_class_value = /*item*/
      ctx[8].classIcon);
      attr_dev(i, "aria-hidden", "true");
      add_location(i, file13, 34, 25, 1024);
      attr_dev(span0, "class", "icon");
      add_location(span0, file13, 34, 6, 1005);
      add_location(span1, file13, 35, 6, 1085);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span0, anchor);
      append_hydration_dev(span0, i);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tabs*/
      1 && i_class_value !== (i_class_value = /*item*/
      ctx2[8].classIcon)) {
        attr_dev(i, "class", i_class_value);
      }
      if (dirty & /*tabs*/
      1 && t1_value !== (t1_value = /*item*/
      ctx2[8].label + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span0);
        detach_dev(t0);
        detach_dev(span1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(34:5) {#if tabs.every(withIcons)}",
    ctx
  });
  return block;
}
function create_each_block5(ctx) {
  let li;
  let a;
  let show_if;
  let t_1;
  let li_class_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (dirty & /*tabs*/
    1)
      show_if = null;
    if (show_if == null)
      show_if = !!/*tabs*/
      ctx2[0].every(
        /*withIcons*/
        ctx2[4]
      );
    if (show_if)
      return create_if_block10;
    return create_else_block8;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  function click_handler() {
    return (
      /*click_handler*/
      ctx[7](
        /*item*/
        ctx[8],
        /*each_value*/
        ctx[9],
        /*item_index*/
        ctx[10]
      )
    );
  }
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      if_block.c();
      t_1 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      a = claim_element(li_nodes, "A", {});
      var a_nodes = children(a);
      if_block.l(a_nodes);
      a_nodes.forEach(detach_dev);
      t_1 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(a, file13, 22, 4, 779);
      attr_dev(li, "class", li_class_value = /*item*/
      ctx[8].isActive ? "is-active" : "");
      add_location(li, file13, 19, 3, 618);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, a);
      if_block.m(a, null);
      append_hydration_dev(li, t_1);
      if (!mounted) {
        dispose = listen_dev(a, "click", click_handler, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(a, null);
        }
      }
      if (dirty & /*tabs*/
      1 && li_class_value !== (li_class_value = /*item*/
      ctx[8].isActive ? "is-active" : "")) {
        attr_dev(li, "class", li_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(19:2) {#each tabs as item}",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let div;
  let ul;
  let div_class_value;
  let t_1;
  let current;
  let each_value = ensure_array_like_dev(
    /*tabs*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t_1 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      ul = claim_element(div_nodes, "UL", {});
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      t_1 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      add_location(ul, file13, 17, 1, 587);
      attr_dev(div, "class", div_class_value = "tabs is-boxed " + /*classSize*/
      ctx[2]);
      add_location(div, file13, 16, 0, 546);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      insert_hydration_dev(target, t_1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*tabs, active, dispatch, withIcons*/
      27) {
        each_value = ensure_array_like_dev(
          /*tabs*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & /*classSize*/
      4 && div_class_value !== (div_class_value = "tabs is-boxed " + /*classSize*/
      ctx2[2])) {
        attr_dev(div, "class", div_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
        detach_dev(t_1);
      }
      destroy_each(each_blocks, detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tab", slots, ["default"]);
  let { classSize = "is-small" } = $$props;
  let { tabs = [
    {
      label: "Pictures",
      classIcon: "fas fa-picture",
      slot: "picture",
      isActive: false
    },
    {
      label: "Calcs",
      classIcon: "fas fa-picture",
      slot: "music",
      isActive: true
    },
    {
      label: "Film",
      classIcon: "fas fa-film",
      slot: "film",
      isActive: false
    }
  ] } = $$props;
  let { active = "" } = $$props;
  const dispatch = createEventDispatcher();
  const withIcons = (currentValue) => currentValue.classIcon && currentValue.classIcon.length > 3;
  const writable_props = ["classSize", "tabs", "active"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Tab> was created with unknown prop '${key}'`);
  });
  const click_handler = (item, each_value, item_index) => {
    tabs.forEach((t) => {
      t.isActive = false;
    });
    $$invalidate(0, each_value[item_index].isActive = true, tabs);
    $$invalidate(1, active = item.slot);
    dispatch(item.slot);
  };
  $$self.$$set = ($$props2) => {
    if ("classSize" in $$props2)
      $$invalidate(2, classSize = $$props2.classSize);
    if ("tabs" in $$props2)
      $$invalidate(0, tabs = $$props2.tabs);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    classSize,
    tabs,
    active,
    dispatch,
    withIcons
  });
  $$self.$inject_state = ($$props2) => {
    if ("classSize" in $$props2)
      $$invalidate(2, classSize = $$props2.classSize);
    if ("tabs" in $$props2)
      $$invalidate(0, tabs = $$props2.tabs);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [tabs, active, classSize, dispatch, withIcons, $$scope, slots, click_handler];
}
var Tab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { classSize: 2, tabs: 0, active: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tab",
      options,
      id: create_fragment13.name
    });
  }
  get classSize() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classSize(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabs() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabs(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tab_default = Tab;

// node_modules/@edwinspire/svelte-components/dist/Menu/Menu.svelte
var file14 = "node_modules/@edwinspire/svelte-components/dist/Menu/Menu.svelte";
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_if_block11(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like_dev(
    /*m*/
    ctx[3].items
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_13(get_each_context_13(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*menu*/
      2) {
        each_value_1 = ensure_array_like_dev(
          /*m*/
          ctx2[3].items
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_13(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_13(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(28:3) {#if showItems}",
    ctx
  });
  return block;
}
function create_each_block_13(ctx) {
  let li;
  let a;
  let t0_value = (
    /*item*/
    ctx[6].label + ""
  );
  let t0;
  let a_class_value;
  let t1;
  let li_transition;
  let current;
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      a = claim_element(li_nodes, "A", { class: true });
      var a_nodes = children(a);
      t0 = claim_text(a_nodes, t0_value);
      a_nodes.forEach(detach_dev);
      t1 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "class", a_class_value = /*item*/
      ctx[6].isActive ? "is-active" : "");
      add_location(a, file14, 31, 6, 572);
      add_location(li, file14, 30, 5, 537);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, a);
      append_hydration_dev(a, t0);
      append_hydration_dev(li, t1);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (!li_transition)
          li_transition = create_bidirectional_transition(li, slide, {}, true);
        li_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      if (!li_transition)
        li_transition = create_bidirectional_transition(li, slide, {}, false);
      li_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (detaching && li_transition)
        li_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_13.name,
    type: "each",
    source: "(29:4) {#each m.items as item}",
    ctx
  });
  return block;
}
function create_each_block6(ctx) {
  let p;
  let t0_value = (
    /*m*/
    ctx[3].main + ""
  );
  let t0;
  let t1;
  let ul;
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*showItems*/
    ctx[0] && create_if_block11(ctx)
  );
  const block = {
    c: function create() {
      p = element("p");
      t0 = text(t0_value);
      t1 = space();
      ul = element("ul");
      if (if_block)
        if_block.c();
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      t0 = claim_text(p_nodes, t0_value);
      p_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      ul = claim_element(nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      if (if_block)
        if_block.l(ul_nodes);
      t2 = claim_space(ul_nodes);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(p, "class", "menu-label");
      add_location(p, file14, 18, 2, 306);
      attr_dev(ul, "class", "menu-list");
      add_location(ul, file14, 26, 2, 411);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, ul, anchor);
      if (if_block)
        if_block.m(ul, null);
      append_hydration_dev(ul, t2);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          p,
          "click",
          /*click_handler*/
          ctx[2],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*showItems*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*showItems*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block11(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(ul, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
        detach_dev(t1);
        detach_dev(ul);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(18:1) {#each menu as m}",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let aside0;
  let t0;
  let aside1;
  let p0;
  let textContent = "General";
  let t2;
  let ul0;
  let li0;
  let a0;
  let textContent_1 = "Dashboard";
  let t4;
  let li1;
  let a1;
  let textContent_2 = "Customers";
  let t6;
  let p1;
  let textContent_3 = "Administration";
  let t8;
  let ul2;
  let li2;
  let a2;
  let textContent_4 = "Team Settings";
  let t10;
  let li6;
  let a3;
  let textContent_5 = "Manage Your Team";
  let t12;
  let ul1;
  let li3;
  let a4;
  let textContent_6 = "Members";
  let t14;
  let li4;
  let a5;
  let textContent_7 = "Plugins";
  let t16;
  let li5;
  let a6;
  let textContent_8 = "Add a member";
  let t18;
  let li7;
  let a7;
  let textContent_9 = "Invitations";
  let t20;
  let li8;
  let a8;
  let textContent_10 = "Cloud Storage Environment Settings";
  let t22;
  let li9;
  let a9;
  let textContent_11 = "Authentication";
  let t24;
  let p2;
  let textContent_12 = "Transactions";
  let t26;
  let ul3;
  let li10;
  let a10;
  let textContent_13 = "Payments";
  let t28;
  let li11;
  let a11;
  let textContent_14 = "Transfers";
  let t30;
  let li12;
  let a12;
  let textContent_15 = "Balance";
  let current;
  let each_value = ensure_array_like_dev(
    /*menu*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      aside0 = element("aside");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      aside1 = element("aside");
      p0 = element("p");
      p0.textContent = textContent;
      t2 = space();
      ul0 = element("ul");
      li0 = element("li");
      a0 = element("a");
      a0.textContent = textContent_1;
      t4 = space();
      li1 = element("li");
      a1 = element("a");
      a1.textContent = textContent_2;
      t6 = space();
      p1 = element("p");
      p1.textContent = textContent_3;
      t8 = space();
      ul2 = element("ul");
      li2 = element("li");
      a2 = element("a");
      a2.textContent = textContent_4;
      t10 = space();
      li6 = element("li");
      a3 = element("a");
      a3.textContent = textContent_5;
      t12 = space();
      ul1 = element("ul");
      li3 = element("li");
      a4 = element("a");
      a4.textContent = textContent_6;
      t14 = space();
      li4 = element("li");
      a5 = element("a");
      a5.textContent = textContent_7;
      t16 = space();
      li5 = element("li");
      a6 = element("a");
      a6.textContent = textContent_8;
      t18 = space();
      li7 = element("li");
      a7 = element("a");
      a7.textContent = textContent_9;
      t20 = space();
      li8 = element("li");
      a8 = element("a");
      a8.textContent = textContent_10;
      t22 = space();
      li9 = element("li");
      a9 = element("a");
      a9.textContent = textContent_11;
      t24 = space();
      p2 = element("p");
      p2.textContent = textContent_12;
      t26 = space();
      ul3 = element("ul");
      li10 = element("li");
      a10 = element("a");
      a10.textContent = textContent_13;
      t28 = space();
      li11 = element("li");
      a11 = element("a");
      a11.textContent = textContent_14;
      t30 = space();
      li12 = element("li");
      a12 = element("a");
      a12.textContent = textContent_15;
      this.h();
    },
    l: function claim(nodes) {
      aside0 = claim_element(nodes, "ASIDE", { class: true });
      var aside0_nodes = children(aside0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(aside0_nodes);
      }
      aside0_nodes.forEach(detach_dev);
      t0 = claim_space(nodes);
      aside1 = claim_element(nodes, "ASIDE", { class: true });
      var aside1_nodes = children(aside1);
      p0 = claim_element(aside1_nodes, "P", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(p0) !== "svelte-1msux1h")
        p0.textContent = textContent;
      t2 = claim_space(aside1_nodes);
      ul0 = claim_element(aside1_nodes, "UL", { class: true });
      var ul0_nodes = children(ul0);
      li0 = claim_element(ul0_nodes, "LI", {});
      var li0_nodes = children(li0);
      a0 = claim_element(li0_nodes, "A", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(a0) !== "svelte-5dj032")
        a0.textContent = textContent_1;
      li0_nodes.forEach(detach_dev);
      t4 = claim_space(ul0_nodes);
      li1 = claim_element(ul0_nodes, "LI", {});
      var li1_nodes = children(li1);
      a1 = claim_element(li1_nodes, "A", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(a1) !== "svelte-pk7crb")
        a1.textContent = textContent_2;
      li1_nodes.forEach(detach_dev);
      ul0_nodes.forEach(detach_dev);
      t6 = claim_space(aside1_nodes);
      p1 = claim_element(aside1_nodes, "P", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(p1) !== "svelte-17bb8wr")
        p1.textContent = textContent_3;
      t8 = claim_space(aside1_nodes);
      ul2 = claim_element(aside1_nodes, "UL", { class: true });
      var ul2_nodes = children(ul2);
      li2 = claim_element(ul2_nodes, "LI", {});
      var li2_nodes = children(li2);
      a2 = claim_element(li2_nodes, "A", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(a2) !== "svelte-1ygmrow")
        a2.textContent = textContent_4;
      li2_nodes.forEach(detach_dev);
      t10 = claim_space(ul2_nodes);
      li6 = claim_element(ul2_nodes, "LI", {});
      var li6_nodes = children(li6);
      a3 = claim_element(li6_nodes, "A", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(a3) !== "svelte-77iyhv")
        a3.textContent = textContent_5;
      t12 = claim_space(li6_nodes);
      ul1 = claim_element(li6_nodes, "UL", {});
      var ul1_nodes = children(ul1);
      li3 = claim_element(ul1_nodes, "LI", {});
      var li3_nodes = children(li3);
      a4 = claim_element(li3_nodes, "A", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(a4) !== "svelte-1i90w2x")
        a4.textContent = textContent_6;
      li3_nodes.forEach(detach_dev);
      t14 = claim_space(ul1_nodes);
      li4 = claim_element(ul1_nodes, "LI", {});
      var li4_nodes = children(li4);
      a5 = claim_element(li4_nodes, "A", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(a5) !== "svelte-6fqbma")
        a5.textContent = textContent_7;
      li4_nodes.forEach(detach_dev);
      t16 = claim_space(ul1_nodes);
      li5 = claim_element(ul1_nodes, "LI", {});
      var li5_nodes = children(li5);
      a6 = claim_element(li5_nodes, "A", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(a6) !== "svelte-fysgwu")
        a6.textContent = textContent_8;
      li5_nodes.forEach(detach_dev);
      ul1_nodes.forEach(detach_dev);
      li6_nodes.forEach(detach_dev);
      t18 = claim_space(ul2_nodes);
      li7 = claim_element(ul2_nodes, "LI", {});
      var li7_nodes = children(li7);
      a7 = claim_element(li7_nodes, "A", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(a7) !== "svelte-1p3crim")
        a7.textContent = textContent_9;
      li7_nodes.forEach(detach_dev);
      t20 = claim_space(ul2_nodes);
      li8 = claim_element(ul2_nodes, "LI", {});
      var li8_nodes = children(li8);
      a8 = claim_element(li8_nodes, "A", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(a8) !== "svelte-nv1f32")
        a8.textContent = textContent_10;
      li8_nodes.forEach(detach_dev);
      t22 = claim_space(ul2_nodes);
      li9 = claim_element(ul2_nodes, "LI", {});
      var li9_nodes = children(li9);
      a9 = claim_element(li9_nodes, "A", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(a9) !== "svelte-1xytjf8")
        a9.textContent = textContent_11;
      li9_nodes.forEach(detach_dev);
      ul2_nodes.forEach(detach_dev);
      t24 = claim_space(aside1_nodes);
      p2 = claim_element(aside1_nodes, "P", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(p2) !== "svelte-12lg2pw")
        p2.textContent = textContent_12;
      t26 = claim_space(aside1_nodes);
      ul3 = claim_element(aside1_nodes, "UL", { class: true });
      var ul3_nodes = children(ul3);
      li10 = claim_element(ul3_nodes, "LI", {});
      var li10_nodes = children(li10);
      a10 = claim_element(li10_nodes, "A", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(a10) !== "svelte-czara1")
        a10.textContent = textContent_13;
      li10_nodes.forEach(detach_dev);
      t28 = claim_space(ul3_nodes);
      li11 = claim_element(ul3_nodes, "LI", {});
      var li11_nodes = children(li11);
      a11 = claim_element(li11_nodes, "A", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(a11) !== "svelte-k09y42")
        a11.textContent = textContent_14;
      li11_nodes.forEach(detach_dev);
      t30 = claim_space(ul3_nodes);
      li12 = claim_element(ul3_nodes, "LI", {});
      var li12_nodes = children(li12);
      a12 = claim_element(li12_nodes, "A", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(a12) !== "svelte-fkzmqi")
        a12.textContent = textContent_15;
      li12_nodes.forEach(detach_dev);
      ul3_nodes.forEach(detach_dev);
      aside1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(aside0, "class", "menu");
      add_location(aside0, file14, 16, 0, 264);
      attr_dev(p0, "class", "menu-label");
      add_location(p0, file14, 40, 1, 714);
      add_location(a0, file14, 42, 6, 778);
      add_location(li0, file14, 42, 2, 774);
      add_location(a1, file14, 43, 6, 806);
      add_location(li1, file14, 43, 2, 802);
      attr_dev(ul0, "class", "menu-list");
      add_location(ul0, file14, 41, 1, 749);
      attr_dev(p1, "class", "menu-label");
      add_location(p1, file14, 45, 1, 836);
      add_location(a2, file14, 47, 6, 907);
      add_location(li2, file14, 47, 2, 903);
      attr_dev(a3, "class", "is-active");
      add_location(a3, file14, 49, 3, 943);
      add_location(a4, file14, 51, 8, 1001);
      add_location(li3, file14, 51, 4, 997);
      add_location(a5, file14, 52, 8, 1029);
      add_location(li4, file14, 52, 4, 1025);
      add_location(a6, file14, 53, 8, 1057);
      add_location(li5, file14, 53, 4, 1053);
      add_location(ul1, file14, 50, 3, 988);
      add_location(li6, file14, 48, 2, 935);
      add_location(a7, file14, 56, 6, 1105);
      add_location(li7, file14, 56, 2, 1101);
      add_location(a8, file14, 57, 6, 1135);
      add_location(li8, file14, 57, 2, 1131);
      add_location(a9, file14, 58, 6, 1188);
      add_location(li9, file14, 58, 2, 1184);
      attr_dev(ul2, "class", "menu-list");
      add_location(ul2, file14, 46, 1, 878);
      attr_dev(p2, "class", "menu-label");
      add_location(p2, file14, 60, 1, 1223);
      add_location(a10, file14, 62, 6, 1292);
      add_location(li10, file14, 62, 2, 1288);
      add_location(a11, file14, 63, 6, 1319);
      add_location(li11, file14, 63, 2, 1315);
      add_location(a12, file14, 64, 6, 1347);
      add_location(li12, file14, 64, 2, 1343);
      attr_dev(ul3, "class", "menu-list");
      add_location(ul3, file14, 61, 1, 1263);
      attr_dev(aside1, "class", "menu");
      add_location(aside1, file14, 39, 0, 692);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside0, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(aside0, null);
        }
      }
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, aside1, anchor);
      append_hydration_dev(aside1, p0);
      append_hydration_dev(aside1, t2);
      append_hydration_dev(aside1, ul0);
      append_hydration_dev(ul0, li0);
      append_hydration_dev(li0, a0);
      append_hydration_dev(ul0, t4);
      append_hydration_dev(ul0, li1);
      append_hydration_dev(li1, a1);
      append_hydration_dev(aside1, t6);
      append_hydration_dev(aside1, p1);
      append_hydration_dev(aside1, t8);
      append_hydration_dev(aside1, ul2);
      append_hydration_dev(ul2, li2);
      append_hydration_dev(li2, a2);
      append_hydration_dev(ul2, t10);
      append_hydration_dev(ul2, li6);
      append_hydration_dev(li6, a3);
      append_hydration_dev(li6, t12);
      append_hydration_dev(li6, ul1);
      append_hydration_dev(ul1, li3);
      append_hydration_dev(li3, a4);
      append_hydration_dev(ul1, t14);
      append_hydration_dev(ul1, li4);
      append_hydration_dev(li4, a5);
      append_hydration_dev(ul1, t16);
      append_hydration_dev(ul1, li5);
      append_hydration_dev(li5, a6);
      append_hydration_dev(ul2, t18);
      append_hydration_dev(ul2, li7);
      append_hydration_dev(li7, a7);
      append_hydration_dev(ul2, t20);
      append_hydration_dev(ul2, li8);
      append_hydration_dev(li8, a8);
      append_hydration_dev(ul2, t22);
      append_hydration_dev(ul2, li9);
      append_hydration_dev(li9, a9);
      append_hydration_dev(aside1, t24);
      append_hydration_dev(aside1, p2);
      append_hydration_dev(aside1, t26);
      append_hydration_dev(aside1, ul3);
      append_hydration_dev(ul3, li10);
      append_hydration_dev(li10, a10);
      append_hydration_dev(ul3, t28);
      append_hydration_dev(ul3, li11);
      append_hydration_dev(li11, a11);
      append_hydration_dev(ul3, t30);
      append_hydration_dev(ul3, li12);
      append_hydration_dev(li12, a12);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*menu, showItems*/
      3) {
        each_value = ensure_array_like_dev(
          /*menu*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(aside0, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(aside0);
        detach_dev(t0);
        detach_dev(aside1);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Menu", slots, []);
  let showItems = true;
  let menu = [
    {
      main: "General",
      items: [{ label: "A" }, { label: "B", isActive: true }]
    },
    {
      main: "Inicio",
      items: [{ label: "Z" }, { label: "O" }]
    }
  ];
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Menu> was created with unknown prop '${key}'`);
  });
  const click_handler = () => {
    $$invalidate(0, showItems = !showItems);
  };
  $$self.$capture_state = () => ({ slide, showItems, menu });
  $$self.$inject_state = ($$props2) => {
    if ("showItems" in $$props2)
      $$invalidate(0, showItems = $$props2.showItems);
    if ("menu" in $$props2)
      $$invalidate(1, menu = $$props2.menu);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [showItems, menu, click_handler];
}
var Menu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu",
      options,
      id: create_fragment14.name
    });
  }
};
var Menu_default = Menu;

// node_modules/@edwinspire/svelte-components/dist/Select/BasicSelect.svelte
var file15 = "node_modules/@edwinspire/svelte-components/dist/Select/BasicSelect.svelte";
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_each_block7(ctx) {
  let option_1;
  let t0_value = (
    /*h*/
    ctx[6].value + ""
  );
  let t0;
  let t1;
  let option_1_value_value;
  const block = {
    c: function create() {
      option_1 = element("option");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      option_1 = claim_element(nodes, "OPTION", {});
      var option_1_nodes = children(option_1);
      t0 = claim_text(option_1_nodes, t0_value);
      t1 = claim_space(option_1_nodes);
      option_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option_1.__value = option_1_value_value = /*h*/
      ctx[6].id;
      set_input_value(option_1, option_1.__value);
      add_location(option_1, file15, 18, 3, 525);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option_1, anchor);
      append_hydration_dev(option_1, t0);
      append_hydration_dev(option_1, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*options*/
      2 && t0_value !== (t0_value = /*h*/
      ctx2[6].value + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*options*/
      2 && option_1_value_value !== (option_1_value_value = /*h*/
      ctx2[6].id)) {
        prop_dev(option_1, "__value", option_1_value_value);
        set_input_value(option_1, option_1.__value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block7.name,
    type: "each",
    source: "(18:2) {#each options as h}",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let div;
  let select;
  let div_class_value;
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(
    /*options*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      select = claim_element(div_nodes, "SELECT", {});
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (
        /*option*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[4].call(select)
        ));
      add_location(select, file15, 16, 1, 446);
      attr_dev(div, "class", div_class_value = "select " + /*css_class*/
      ctx[2]);
      add_location(div, file15, 15, 0, 412);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*option*/
        ctx[0],
        true
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*select_change_handler*/
            ctx[4]
          ),
          listen_dev(
            select,
            "change",
            /*handleClick*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*options*/
      2) {
        each_value = ensure_array_like_dev(
          /*options*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*option, options*/
      3) {
        select_option(
          select,
          /*option*/
          ctx2[0]
        );
      }
      if (dirty & /*css_class*/
      4 && div_class_value !== (div_class_value = "select " + /*css_class*/
      ctx2[2])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BasicSelect", slots, []);
  const dispatch = createEventDispatcher();
  function handleClick() {
    dispatch("select", { value: option });
  }
  let { options = [{ id: "TEST", value: `TEST`, enabled: true }] } = $$props;
  let { css_class = " is-small" } = $$props;
  let { option = "" } = $$props;
  const writable_props = ["options", "css_class", "option"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BasicSelect> was created with unknown prop '${key}'`);
  });
  function select_change_handler() {
    option = select_value(this);
    $$invalidate(0, option);
    $$invalidate(1, options);
  }
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("css_class" in $$props2)
      $$invalidate(2, css_class = $$props2.css_class);
    if ("option" in $$props2)
      $$invalidate(0, option = $$props2.option);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    handleClick,
    options,
    css_class,
    option
  });
  $$self.$inject_state = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("css_class" in $$props2)
      $$invalidate(2, css_class = $$props2.css_class);
    if ("option" in $$props2)
      $$invalidate(0, option = $$props2.option);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [option, options, css_class, handleClick, select_change_handler];
}
var BasicSelect = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { options: 1, css_class: 2, option: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BasicSelect",
      options,
      id: create_fragment15.name
    });
  }
  get options() {
    throw new Error("<BasicSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<BasicSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get css_class() {
    throw new Error("<BasicSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set css_class(value) {
    throw new Error("<BasicSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get option() {
    throw new Error("<BasicSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set option(value) {
    throw new Error("<BasicSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BasicSelect_default = BasicSelect;

// node_modules/@edwinspire/svelte-components/dist/SlideFullScreen/SlideFullScreen.svelte
var file16 = "node_modules/@edwinspire/svelte-components/dist/SlideFullScreen/SlideFullScreen.svelte";
function add_css9(target) {
  append_styles(target, "svelte-10va6op", ".overlay.svelte-10va6op{height:100%;width:0;position:fixed;z-index:5;top:0;left:0;background-color:rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0.8);overflow-x:hidden;transition:0.5s}.overlay-content.svelte-10va6op{position:relative;padding:1%;height:95%;overflow-y:auto;box-sizing:border-box;margin:1%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2xpZGVGdWxsU2NyZWVuLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFhQyx1QkFBUyxDQUNSLE1BQU0sQ0FBRSxJQUFJLENBQ1osS0FBSyxDQUFFLENBQUMsQ0FDUixRQUFRLENBQUUsS0FBSyxDQUNmLE9BQU8sQ0FBRSxDQUFDLENBQ1YsR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsQ0FBQyxDQUNQLGdCQUFnQixDQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQzlCLGdCQUFnQixDQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQ3BDLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLFVBQVUsQ0FBRSxJQUNiLENBRUEsK0JBQWlCLENBQ2hCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE9BQU8sQ0FBRSxFQUFFLENBQ1gsTUFBTSxDQUFFLEdBQUcsQ0FDWCxVQUFVLENBQUUsSUFBSSxDQUNoQixVQUFVLENBQUUsVUFBVSxDQUN0QixNQUFNLENBQUUsRUFDVCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJTbGlkZUZ1bGxTY3JlZW4uc3ZlbHRlIl19 */");
}
function create_fragment16(ctx) {
  let div2;
  let div1;
  let div0;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "overlay-content box svelte-10va6op");
      add_location(div0, file16, 6, 2, 116);
      attr_dev(div1, "class", "overlay svelte-10va6op");
      set_style(
        div1,
        "width",
        /*show*/
        ctx[0] ? "100%" : "0%"
      );
      add_location(div1, file16, 5, 1, 53);
      add_location(div2, file16, 4, 0, 46);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*show*/
      1) {
        set_style(
          div1,
          "width",
          /*show*/
          ctx2[0] ? "100%" : "0%"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SlideFullScreen", slots, ["default"]);
  let { show = false } = $$props;
  const writable_props = ["show"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SlideFullScreen> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("show" in $$props2)
      $$invalidate(0, show = $$props2.show);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ show });
  $$self.$inject_state = ($$props2) => {
    if ("show" in $$props2)
      $$invalidate(0, show = $$props2.show);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [show, $$scope, slots];
}
var SlideFullScreen = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { show: 0 }, add_css9);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SlideFullScreen",
      options,
      id: create_fragment16.name
    });
  }
  get show() {
    throw new Error("<SlideFullScreen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set show(value) {
    throw new Error("<SlideFullScreen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SlideFullScreen_default = SlideFullScreen;
export {
  BasicSelect_default as BasicSelect,
  DefaultTypes_exports as ColumnTypes,
  Modal_default as DialogModal,
  Level_default as Level,
  Menu_default as Menu,
  Plotter_default as Plotter,
  Predictive_default as PredictiveInput,
  SlideFullScreen_default as SlideFullScreen,
  Tab_default as Tab,
  Table_default as Table,
  WebSocketClient,
  storeChangedTables
};
//# sourceMappingURL=@edwinspire_svelte-components.js.map
