import {
  __commonJS
} from "./chunk-UV5CTPV7.js";

// node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "node_modules/node-fetch/browser.js"(exports, module) {
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    var globalObject = getGlobal();
    module.exports = exports = globalObject.fetch;
    if (globalObject.fetch) {
      exports.default = globalObject.fetch.bind(globalObject);
    }
    exports.Headers = globalObject.Headers;
    exports.Request = globalObject.Request;
    exports.Response = globalObject.Response;
  }
});

// node_modules/@edwinspire/universal-fetch/src/fetch.js
var require_fetch = __commonJS({
  "node_modules/@edwinspire/universal-fetch/src/fetch.js"(exports, module) {
    var fetchData;
    if (typeof window !== "undefined") {
      fetchData = window.fetch;
    } else {
      const fetch = require_browser();
      fetchData = fetch;
    }
    var uFetch = class {
      /**
       *
       * @param {string|undefined} url
       * @param {string|undefined} redirect_in_unauthorized
       */
      constructor(url = void 0, redirect_in_unauthorized = void 0) {
        this._redirect_in_unauthorized_internal = redirect_in_unauthorized;
        this._basic_authentication = {};
        this._bearer_authentication;
        this._url = url;
        this._defaultHeaders = /* @__PURE__ */ new Map();
      }
      /**
       *
       * @param {string} user
       * @param {string} password
       * @returns
       */
      SetBasicAuthentication(user, password) {
        if (user && password) {
          this._basic_authentication = "Basic " + Buffer.from(user + ":" + password).toString("base64");
        } else {
          this._basic_authentication = void 0;
        }
        return this;
      }
      /*
      setBasicAuthorization(user, password) {
        if (user && password) {
          this._basic_authentication =
            "Basic " + Buffer.from(user + ":" + password).toString("base64");
        } else {
          this._basic_authentication = undefined;
        }
        return this;
      }
      */
      setBearerAuthorization(key) {
        if (key) {
          this._bearer_authentication = "Bearer " + key;
        } else {
          this._bearer_authentication = void 0;
        }
        return this;
      }
      _addAuthorizationHeader(headers) {
        if (this._basic_authentication) {
          headers.Authorization = this._basic_authentication;
        }
        if (this._bearer_authentication) {
          headers.Authorization = this._bearer_authentication;
        }
        return headers;
      }
      addHeader(key, value) {
        this._defaultHeaders.set(key, value);
      }
      /**
       *
       * @param {string | undefined} url
       * @param {string} method
       * @param {any | undefined} data
       * @param {any | undefined} headers
       * @returns {Promise}
       */
      async request(url, method, data, headers) {
        let response;
        let m = method ? method.toUpperCase() : "GET";
        let u = url || this._url;
        if (!(m == "GET" || m == "POST" || m == "HEAD" || m == "PUT" || m == "DELETE" || m == "CONNECT" || m == "OPTIONS" || m == "TRACE" || m == "PATCH")) {
          throw "Invalid method";
        }
        if (!headers) {
          headers = {
            "Content-Type": "application/json"
          };
        }
        headers = this._addAuthorizationHeader(headers);
        for (const [key, value] of this._defaultHeaders) {
          headers[key] = value;
        }
        try {
          switch (m) {
            case "POST":
              response = await fetchData(u, {
                method: m,
                body: JSON.stringify(data),
                headers
              });
              break;
            case "PUT":
              response = await fetchData(u, {
                method: m,
                body: JSON.stringify(data),
                headers
              });
              break;
            default:
              let searchURL = new URLSearchParams(data);
              u = u + "?" + searchURL.toString();
              response = await fetchData(u, {
                method: m,
                //            body: JSON.stringify(data),
                headers
              });
              break;
          }
          if (this._redirect_in_unauthorized && response.status == 401) {
            window.location.href = this._redirect_in_unauthorized;
          }
          return response;
        } catch (err) {
          console.log(err);
          if (response)
            return response;
          throw err;
        }
      }
      /**
       *
       * @param {string | undefined} url
       * @param {any | undefined} data
       * @param {any | undefined} headers
       * @returns {Promise}
       */
      async put(url = void 0, data = void 0, headers = void 0) {
        return this.request(url, "PUT", data, headers);
      }
      async PUT(opts) {
        return this.request(opts.url, "PUT", opts.data, opts.headers);
      }
      /**
       *
       * @param {string | undefined} url
       * @param {any | undefined} data
       * @param {any | undefined} headers
       * @returns {Promise}
       */
      async delete(url = void 0, data = void 0, headers = void 0) {
        return this.request(url, "DELETE", data, headers);
      }
      async DELETE(opts) {
        return this.request(opts.url, "DELETE", opts.data, opts.headers);
      }
      /**
       *
       * @param {string | undefined} url
       * @param {any | undefined} data
       * @param {any | undefined} headers
       * @returns {Promise}
       */
      async post(url = void 0, data = void 0, headers = void 0) {
        return this.request(url, "POST", data, headers);
      }
      async POST(opts) {
        return this.request(opts.url, "POST", opts.data, opts.headers);
      }
      /**
       *
       * @param {string | undefined} url
       * @param {any | undefined} data
       * @param {any | undefined} headers
       * @returns {Promise}
       */
      async get(url = void 0, data = void 0, headers = void 0) {
        return this.request(url, "GET", data, headers);
      }
      async GET(opts) {
        return this.request(opts.url, "GET", opts.data, opts.headers);
      }
      /**
       *
       * @param {string | undefined} url
       * @param {any | undefined} data
       * @param {any | undefined} headers
       * @returns {Promise}
       */
      async patch(url = void 0, data = void 0, headers = void 0) {
        return this.request(url, "PATCH", data, headers);
      }
      async PATCH(opts) {
        return this.request(opts.url, "PATCH", opts.data, opts.headers);
      }
    };
    module.exports = uFetch;
  }
});

export {
  require_fetch
};
//# sourceMappingURL=chunk-WTP6JZ2J.js.map
